[
    {
        "pptName": "Unit 2",
        "slides": [
            "```\fUnit 2: Peer-to-Peer Networking2. 1Introduction2. 2P2P Topologies2. 3P2P Applications2. 4P2P and the Internet2. 5Unstructured overlay topology2. 6Structured overlay topologyReading: Chapters 29, Textbook – Forouzan || Unit 2 - 2```",
            "```\f2. 1 Introduction || Unit 2 - 3```",
            "```\fDefinition of P2P SystemsThere is no universally accepted definition of P2P systems, although thereare many definitions, and there are some common characteristics shared bymost P2P systems:A ‘peer’ is a computer that can act as both server and/or client. A P2P system should consist of at least two or more peers. Peers should be able to exchange resources directly among themselves. Such resources include files, storages, information, central processingunit (CPU) power and knowledge. Dedicated servers may or may not be present in a P2P systemdepending on the nature of the applications. P2P systems without dedicated servers are sometimes described as‘pure’ P2P systems. Peers can join and/or leave the system freely.  || Unit 2 - 4```",
            "```\fBenefits of P2P SystemsWorkload is spread to all peersIt is possible to have millions of computers in a P2P network, which can deliverhuge resources and power. Maximize system utilizationMany office computers are not used at all from 5 pm to 9 am in the nextmorning.  P2P computer can use these resources and thus maximize theutilization. No central point of failureE. g. , the Internet and the Web do not have a central point of failure. P2P network will still function when some of its peers are not working properly. Thus it is more fault tolerant than other systems (e. g.  C/S). ScalabilitySince every peer is alike, it is possible to add more peers to the system and scaleto larger networks.  || Unit 2 - 5```",
            "```\fDisadvantages of P2P ComputingThe peer will be more susceptible to hackers’ attacks. It is difficult to enforce standards in P2P systems. A P2P network cannot guarantee that a particular resource will be availableall the time. For example, the owner may shut down his/her computer or delete afile. It is difficult to predict the overall performance of a system. It is difficult to prevent illegal uploading and downloading of copyrightedmaterials. A popular P2P system can generate enormous amount of network traffic. As a result, some universities did not allow their students to accesssome P2P applications inside the campus.  || Unit 2 - 6```",
            "```\f2. 2 P2P Topologies || Unit 2 - 7```",
            "```\fP2P TopologiesCentralizedRingHierarchicalDecentralizedHybrid || Unit 2 - 8```",
            "```\fCentralized TopologyCentralized systems are the most familiar form of topology. Typically seen as the client/server pattern used bydatabases, web servers,and other simple distributed systems. All function and information is centralizedinto one server with many clients connectingdirectly to the server to send and receiveinformation. Many \"peer-to-peer\" applicationsalso have a centralized component. The original Napster's search architecturewas centralized, although the file sharing was not.  || Unit 2 - 9```",
            "```\fRing TopologyA single centralized server cannot handle high clients loadA common solution is to use a cluster of machinesarranged in a ring to act as a distributed servers. Communication between the nodescoordinates state-sharing, to provideidentical functionWith fail-over andload-balancing capabilities. Ring systems are generally built onthe assumption thatthe machines are all nearby on the networkand owned by a single organization.  || Unit 2 - 10```",
            "```\fHierarchical TopologyHierarchical systems have a long history on the InternetThe best-known hierarchical system on the Internetis the Domain Name Service,where authority flows fromthe root name-servers to the serverfor the registered name. The Network Time Protocol (NTP) isa protocol for synchronizing the clocksof computer systems over networksthere are root time servers that have authoritative clocks; othercomputers synchronize to root time servers in a self-organizing tree.  || Unit 2 - 11```",
            "```\fDecentralized TopologyThis is the opposite of centralized topologyAll peers communicate symmetrically and have equal roles. Decentralized systems are not new;the Internet routing architecture islargely decentralized, with theBorder Gateway Protocol betweenvarious autonomous systems. Gnutella is probably the most \"pure\"decentralized system used in practice today || Unit 2 - 12```",
            "```\fHybrid Topology: Centralized + RingReal-world systems often combine several topologies into one system,making a hybrid topology. Nodes typically play multiple rolesin such a system. For example, a node might havea centralized interaction with onepart of the system, while beingpart of a ring with other nodes. Centralized + RingMost web server applications often havea ring of servers for load balancing and failover. The system as a whole is a hybrid: a centralized system for clientswhere the server is itself a ring.  || Unit 2 - 13```",
            "```\fHybrid Topology: Centralized + DecentralizedCentralized + DecentralizedAdvancing an architecture ofcentralized systems embeddedin decentralized systems. Most peers have a centralizedrelationship to a \"supernode\"forwarding all file queries tothis serverBut instead of supernodes beingstandalone servers, they bandthemselves together in adecentralized network, propagating queries.  || Unit 2 - 14```",
            "```\fEvaluating TopologiesManageabilityHow hard is it to keep working, in terms of updating, repairing, and logging?Information coherenceIf a bit of data is found in the system, is that data correct? (Non-repudiation anddata consistency)ExtensibilityHow easy is the system to grow?Fault toleranceHow well can it handle failures?Resistance to legal or political interventionHow hard is it to shut down? (Can be good or bad)SecurityHow hard is the system to be attacked?ScalabilityHow big can the system grow? || Unit 2 - 15```",
            "```\fCentralizedManageableCoherentExtensible✓ System is all in one place✓ All information is in one placeX Resources (CPU/Data) can only beadded to the central systemFault TolerantSecureX Single point of failure✓ Simply only one host that needsto be protectedLawsuit-proofScalableX Easy to shut downLimited by the capacity of the server.  || Unit 2 - 16```",
            "```\fRingManageableCoherentExtensibleFault TolerantSecureLawsuit-proofScalable✓ Typically have a single owner, withrules for relationships✓ Easy logic for stateX Only ring owner can add (a user stillneeds the owner's permission to adda resource like a music file or a Webpage into the ring)✓ Fail-over to next host✓ As long as ring has one ownerX Shut down owner✓ Just add more hosts || Unit 2 - 17```",
            "```\fHierarchicalManageable½ Chain of authorityCoherent½ Cache consistencyExtensible½ Add more leaves, rebalanceFault Tolerant½ the root is still a single pointof failureSecureLawsuit-proofScalable½ It is not just the root that is a riskX Just shut down the root✓ Hugely scalable – DNS || Unit 2 - 18```",
            "```\fDecentralizedManageableCoherentExtensibleFault TolerantSecureLawsuit-proofScalableX Very difficult, many ownersX Difficult, unreliable peers✓ Anyone can join in!✓ RedundancyX Difficult, open research✓ No one to sueTheory – yes : Practice – no || Unit 2 - 19```",
            "```\fCentralized + RingManageable✓ Just manage the ringCoherent✓ As coherent as ringExtensibleX No more than ringFault Tolerant✓ Ring is a huge winSecureLawsuit-proofScalable✓ As secure as ringX Still single place to shut down✓ Ring is a huge winCommon architecture for web applications || Unit 2 - 20```",
            "```\fCentralized + DecentralizedManageableCoherentX Same as decentralized½ Better than decentralizedfewer hosts that are holding authoritative dataExtensible✓ Anyone can still join!Fault Tolerant✓ Plenty of redundancySecureLawsuit-proofScalableX Same as decentralized✓ Still no one to sueLooking very hopefullyBest architecture for P2P networks || Unit 2 - 21```",
            "```\f2. 3 P2P Applications || Unit 2 - 22```",
            "```\fP2P Computing ApplicationsFile sharingImproves data availabilityReplication to compensate for failures. E. g. , Napster, Gnutella, Freenet, KaZaA (FastTrack). Process sharingFor large-scale computationsData analysis, data mining, scientific computingCollaborative environmentsFor remote real-time human collaboration. Instant messaging, shared whiteboards, teleconferencingE. g. , Skype, Messenger.  || Unit 2 - 23```",
            "```\fP2P Technical ChallengesPeer identificationRouting protocolsNetwork topologiesPeer discoveryCommunication/coordination protocolsQuality of serviceSecurity || Unit 2 - 24```",
            "```\fFamous Napster ModelCreated in 1999 by Shawn Fanning, an 18-year-old studentNapster is P2P application network, which gives its members ability to connectdirectly to other members’ computers and search their hard drives for digital musicfiles to share and trade. Members download a software package from Napster and install it on theircomputers. The Napster central computer maintains directories of music files of members whoare currently connected to the network.  These directories are automatically updatedwhen a member logs on or off the network. Whenever a member submits a request to search for a file, the central computerprovides information to the requesting member. The requesting member can then establish a connection directly with anothermember’s computer containing that particular file. The download of the target file takes place directly between the members’computers, bypassing the central computer.  || Unit 2 - 25```",
            "```\fNapster Model || Unit 2 - 26```",
            "```\fNapster ModelOver 36 million people joined the Napster communityIt rapidly accelerated the development and implementation of other P2P models. The limitation is that it can only share music filesIn July 2001, The Recording Industry Association of America (RIAA), ordered toshutdown Napster due to the free copying of copyrighted material.  || Unit 2 - 27```",
            "```\fOther P2P SystemsNapster was ordered to shut down because it maintained a central directoryfor its members. New file-sharing P2P systems bypass the legal problems as they do nothold a central directoryThey do not even need a central server or any company to run the system. Thus, it is impossible to kill the network. These new P2P systems include Gnutella, KaZaA, LimeWire , DirectConnect, etc.  || Unit 2 - 28```",
            "```\fThe network structure of GnutellaThe idea of Gnutella is similar to the ‘searchstrategies’ employed by humans. If you want to get a particular file, you can ask one ofyour friends.  If he/she does not have the file, he/shecan ask his/her friends.  This request will be conveyedfrom one person to another until it reaches someonewho has the file. This piece of information will be routed to youaccording to the original path. Computers in the network have different connectionspeeds. A high-speed computer will connect to manycomputers, while the low-speed computer willconnect to only a few computers. Over the course of time, the network will have ahigh-speed computer in the core.  || Unit 2 - 29```",
            "```\fBitTorrent (Motivation)An analysis by Xerox Research Center indicated that50% of all files for sharing were stored on only 1% of the peers. About 70% of all Gnutella users do not share any files with others. In other word, all they do is ‘download’.  They are referred to as “free loaders”or “free riders”When a peer shares a popular file with othersin a P2P network, it will attract a large volumeof traffic.  And hence this peer needs to paymore bandwidth costs for more clientsA large proportion of freeloaders,will defeat the objective to shareworkload in a P2P network.  || Unit 2 - 30```",
            "```\fBitTorrent (Model)BitTorrent is a P2P protocol, designed by Bram Cohen, for sharing a large file amonga set of peers. The term file-sharing means that instead of download the whole file from one peer,the file can be downloaded from a group of peers,because the file is divided into number of parts that are distributed among thisgroup of peers. File sharing is done in a collaborating process called a torrent. Each peer participating in a torrent downloads chunksof the large file from another peer that has it anduploads chunks of that file to other peers that donot have it. The performance will be improved because there isno way to turn off the upload function of aBitTorrent program when a computer is downloading.  || Unit 2 - 31```",
            "```\fBitTorrent (Model)The set of all peers that takes part in a torrent is referred to as a swarm. A peer in a swarm that has the complete content file is called a seed. A peer that has only part of the file and wants to download the rest is called a leech. In other words, a swarm is a combinationof seeds and leeches. BitTorrent has gone throughseveral versions and implementations. The original one, uses a centralnode called a tracker, to trackthe operation of the swarm. The new versions eliminate thetracker by using DHT (more later).  || Unit 2 - 32```",
            "```\fBitTorrent – How does it work?Now assume a new peer wants to download a content of a common file. The new peer search the Internet for the corresponding metafile of this content.  This fileis called a Torrent file. The Torrent file contains:File name# of chunks (pieces), sizechecksumIP address of the Tracker,…etc. Using this Torrent file, the new peer uses a BitTorrent client application to access thetracker and receives the addresses of some peers in the torrent, normally calledneighbours. The new peer is now part of the torrent and can download and upload pieces of thecontent file. Nothing can prevent a peer from leaving the torrent before it has all the pieces and joininglater or not joining again. The BitTorrent protocol applies a set of policies to provide fairness and to preventoverloading a peer with requests from other peers.  || Unit 2 - 33```",
            "```\fBitTorrent – Policies (1)To avoid overloading and to achieve fairness,each peer needs to limit its concurrent connection to a number of neighbours; the typical value isfour. A peer flags a neighbour as unchoked or choked. It also flags them as interested or uninterested. This means, the provided neighbors list will be divided into unchoked/choked, andinterested/uninterested. The unchoked group is the list of peers that the current peer has concurrently connected to; itcontinuously uploads and downloads pieces from this group. The choked group is the list of neighbours that the peer is not currently connected to but mayconnect to in the future. Every 10 seconds, the current peer tries one peer from the interested but choked group fora better data rate.  If it has a better rate than any of the unchoked peers, their status maybe swapped. This strategy divides the neighbours into subgroups in which those neighbours with compatibledata transfer rates will communicate with each other || Unit 2 - 34```",
            "```\fBitTorrent – Policies (2)To allow a newly joined peer, which does not yet have a piece to share, to alsoreceive pieces from other peers,Every 30 seconds the system randomly promotes a single peer, regardless of itsuploading rate, from the choked/uninterested group and flags it as unchoked. This action is called optimistic unchoking. A balance between the number of pieces that each peer may have is managed by astrategy called the rarest-first. Using this strategy, a peer tries to first download the pieces with the fewestrepeated copies among the neighbours. In this way, these pieces are circulated faster.  || Unit 2 - 35```",
            "```\f2. 4 P2P and the Internet(Overlay, Structured, Unstructured) || Unit 2 - 36```",
            "```\fP2P Overlays and Network ServicesPeers in P2P applications communicate with other peers using messagestransmitted over the Internet or other types of networks. The protocols of various P2P applications have some common features. protocols are constructed at the application layer. peers have a unique identifier, which is the peer ID or peer address. P2P protocols support some type of message-routing capability. a message intended for one peer can be transmitted viaintermediate peers to reach the destination peer.  || Unit 2 - 37```",
            "```\fP2P Overlays and Network ServicesTo distinguish the operation of the P2P protocol at the application layerfrom the behavior of the underlying physical network,the collection of peer connections in a P2P network is calleda P2P overlayNext slide shows the correspondence between peers connecting in anoverlay network with the corresponding nodes in the underlying physicalnetwork || Unit 2 - 38```",
            "```\fPeers form an overlay network (top) uses network connections in the native network (bottom)The overlay organization is a logical view that might not directly mirror the physical network || Unit 2 - 39```",
            "```\fOverlay Networks TypesDepending on how the nodes in a P2P overlay are linked, the overlay network can beclassified as eitherUnstructured or Structured overlay networksUnstructured NetworksThe nodes are linked randomly. A search in unstructured P2P is not very efficient, and a query may not be resolved. (more details later)Gnutella and Freenet are examples of unstructured P2P networks. Structured NetworksUse a predefined set of rules to link nodes so that a query can be effectively andefficiently resolved. The most common technique used for this purpose is the Distributed Hash Table(DHT). One popular P2P file sharing protocol that uses the DHT is BitTorrent.  || Unit 2 - 40```",
            "```\fDistributed Hash Table (DHT)DHT distributes data items (objects) among a set of nodes according to somepredefined rules. Each peer in a DHT-based network becomes responsible for a range of data items. Each data item and the responsible peer is mapped to a point in a large addressspace of size 2m.  (Most of the DHT implementations use m=160)The address space is designed using modular arithmetic, which means that the pointsin the address space is distributed on a circle with 2m points (0 to 2m – 1) usingclockwise direction as shown:Note:1.  Space range is 0 to 2m -12.  Calculation is done modulo 2m(3/4) x 2mAddress spaceof size 2m(1/4) x 2m(1/2) x 2m || Unit 2 - 41```",
            "```\fDHT - Hashing Peer/Object IdentifierThe first step in creating the DHT system is to place all peers on the address spacering. This is normally done by using a hash function that hashes the peer identifier,normally its IP address, to an m-bit integer, called a node ID. node ID = hash (Peer IP address)DHT uses some of the cryptographic hash functions such as Secure Hash Algorithm(SHA-1) that are collision resistant. The name of the object (for example, a file) to be shared is also hashed to an m-bitinteger in the same address space, called a key. key = hash (Object name)In the DHT an object is normally related to the pair (key, value) in which the key isthe hash of the object name and the value is the object or a reference to theobject.  || Unit 2 - 42```",
            "```\fDHT - Storing the ObjectThere are two strategies for storing the object:A direct method:The object is stored in the node whose ID is closest to the key in the ring. The term closest is defined differently in each protocol. An indirect method:The peer that owns the object keeps the object, but a reference to theobject is created and stored in the node whose ID is closest to the keypoint. This means, the physical object and the reference to the object are stored intwo different locations (peers). Most DHT systems use the indirect method due to efficiency. In either case, a search mechanism is needed to find the object if the name of theobject is given.  || Unit 2 - 43```",
            "```\fDHT - ExampleThe normal value of m is 160, for the purpose of demonstration, we use m = 5. The node N5 with IP address 110. 34. 56. 23 has a file named “SE3314b-Assignment“ that it wantsto share with its peers. The file is stored in N5, the key of the file is k14, butthe reference to the file is stored in node N17. SE3314b-AssignmentLegend5200key = hash (object name)node = hash (IP address)point (potential key or node)(110. 34. 56. 23)N2N29N5N25Key14Reference(110. 34. 56. 23:5200)N10N20N17(129. 100. 224. 11)5=hash (110. 34. 56. 23)ID space ofsize 25 (m=5)K1414=hash (“SE3314b-Assignment”) || Unit 2 - 44```",
            "```\f2. 5 Unstructured overlay topology || Unit 2 - 45```",
            "```\fUnstructured OverlayAn unstructured P2P network is formed when the overlay links are establishedarbitrarily. Unstructured overlays, for example Gnutella,organize nodes into a random graph anduse floods or random walks to discover data stored by overlay nodes. Each node visited during a flood or random walk evaluates the query locally on thedata items that it stores. Unstructured overlays does not impose any constraints on the node graph or on dataplacement,for example, each node can choose any other node to be its neighbour in theoverlayUnstructured overlays cannot find rare data items efficiently, and it does notguarantee that an object can be found if it exists in the overlay.  || Unit 2 - 46```",
            "```\fFlooding and Expanding RingWhen each peer keeps a list of its neighbors,and when this neighbor relations are transitive,we will have connectivity graphs such as the one shown in this figureIn this particular graph:peers have degree from 2 to 5Increasing the degree reducesthe diameter of the overlay, butrequires more storage at each peer. Peers can exchange messages withother peers in its neighbor list. Message can be a query that containsthe search criteria, such as a filename or keywords. We don’t know which peers in the overlay have the information, so to whom thequery will be sent? || Unit 2 - 47```",
            "```\fFlooding AlgorithmSimple algorithm: (flooding)Peer could try sending a query to all its neighbor.  If the neighbor peers don’thave the information, they can in turn forward the request to their neighbors,and so on. But, how to prevent messages from circulating endlessly?Using message identifiersAttach (TTL) value toa message to limits its lifetime.  || Unit 2 - 48```",
            "```\fFlooding AlgorithmFloodForward(Query q, Source p)// have we seen this query before?if(q. id  oldIdsQ) return // yes, drop itoldIdsQ = oldIdsQ  q. id // remember this query// expiration time reached?q. TTL = q. TTL – 1if q. TTL  0 then return // yes, drop it// no, forward it to remaining neighborsforeach(s  Neighbors) if(s  p) FloodForward(q,s)Each peer has a list of neighbors. It initializes its list of neighbors when it joins the overlayfor example, by getting a copy of the neighbor list of the first peer that it connects toWhen the query is satisfied at some peer, a response message is sent to the requesting peer. If the object is not found quickly, the flooding mechanism continues to propagate the querymessage along other paths until the TTL value expires or the query is satisfied.  || Unit 2 - 49```",
            "```\fExpanding RingFlooding mechanism creates substantial redundant messaging, which is inefficient forthe network. We may start the search with a small TTL value.  If this succeeds, the search stops. Otherwise, the TTL value is increased by a small amount and the query is reissued. This variation of flooding is called iterative deepening or expanding ring || Unit 2 - 50```",
            "```\fRandom WalkTo avoid the message overhead of flooding, unstructured overlays can use some typeof random walk. In random walk a single query message is sent to a randomly selected neighbor. The message has a TTL value that is decremented at each hop. If the desired object is found, the search terminates. Otherwise the query fails, by a timeout or an explicit failure messageThe same process may be repeated to another randomly chosen path. To improve the response time, several random walk queries can be issued in parallel || Unit 2 - 51```",
            "```\fRandom Walk AlgorithmRandomWalk(source, query, TTL)if (TTL > 0) {TTL = TTL – 1// select next hop at random, don’t send back to sourcewhile((next_hop = neighbors[random()]) == source){}RandomWalk(source, query, TTL) || Unit 2 - 52```",
            "```\fSummaryUnstructured overlays have been used in several widely used filesharing systems, despite their inefficiencies. In the research community there has been much effort to increasetheir performance and reduce overhead. Structured overlays, emerged to address limitations of unstructuredoverlays by combining a specific geometrical structure withappropriate routing and maintenance mechanisms.  || Unit 2 - 53```",
            "```\f2. 6 Structured overlay topology || Unit 2 - 54```",
            "```\fMotivation and CategoriesThe earliest peer-to-peer systems used unstructured overlays that wereeasy to implement but had inefficient routing and an inability to locate rareobjects. These problems turned the attentions to design overlays with routingmechanisms thatare deterministic and that can provide guarantees on the ability tolocate any object stored in the overlay. The large majority of these designs used overlays with a specific routinggeometry and are called structured overlays.  || Unit 2 - 55```",
            "```\fStructured overlays & Directed SearchesIdea:Assign particular nodes to hold particular content (or pointers to it, likean information booth)When a node wants that content, go to the node that is supposed tohave or know about itChallenges:Distributed: want to distribute responsibilities among existing nodes inthe overlayAdaptive: nodes join and leave the P2P overlaydistribute knowledge responsibility to joining nodesredistribute responsibility knowledge from leaving nodes || Unit 2 - 56```",
            "```\fStructured overlays & Directed SearchesStructured overlays support key-based routing such thatobject identifiers are mapped to the peer identifier address space andan object request (lookup message) is routed to the nearest peer inthe peer address space. P2P systems using key-based routing are called distributed object locationand routing (DOLR) systems. A specific type of DOLR is a distributed hash table (DHT)In this Unit, we introduce three of these protocols:Pastry,Kademlia, andChord.  || Unit 2 - 57```",
            "```\fDHT - ExampleThe normal value of m is 160, for the purpose of demonstration, we use m = 5. The node N5 with IP address 110. 34. 56. 23 has a file named “SE3314b-Assignment“ that it wantsto share with its peers. The file is stored in N5, the key of the file is k14, butthe reference to the file is stored in node N17. SE3314b-AssignmentLegend5200key = hash (object name)node = hash (IP address)point (potential key or node)(110. 34. 56. 23)N2N29N5N25Key14Reference(110. 34. 56. 23:5200)N10N20N17(129. 100. 224. 11)5=hash (110. 34. 56. 23)ID space ofsize 25 (m=5)K1414=hash (“SE3314b-Assignment”) || Unit 2 - 58```",
            "```\fPastryPastry is designed by Antony Rowstron and Peter Druschel in 2001, and uses DHT. Nodes and data items are identified by m-bit IDs that create an identifier space ofsize 2m points distributed in a circle in the clockwise direction. The common value for m is 128.  The protocol uses the SHA-1 hashing algorithmwith m = 128. In Pastry, an identifier is seen as an n-digit string in base 2b in which b is normally 4and n = (m/b). For instance, an identifier is a 32-digit number in base 16 (hexadecimal). A key is stored in the node whose identifier is numerically closest to the key || Unit 2 - 59```",
            "```\fPastry - RoutingEach node in Pastry can resolve a query using two entities: a routing table and a leafset. (2b) columns. when m = 128 , b = 4, we have 16 columnsRouting Tablen rows. when m =128 , b = 4,we have 32(128/4) rowsCommonprefix length31For node N, Table [i, j], gives the ID of a node (if it exists) that shares the i leftmost digits withthe ID for N and its (i+1)th digit has a value of j. The first row, row 0, shows the list of live nodes whose identifiers have no common prefix with N. The last row, row 31, shows the list of all live nodes that share the leftmost 31 digits with nodeN; only the last digit is different.  || Unit 2 - 60```",
            "```\fRouting Table, ExampleAssume the node N ID is (574A234B12E374A2001B23451EEE4BCD)16then the value of the Table [2, D] can be the identifier of a node such as (57D. . . ). Commonprefix length57D…31Note that the leftmost two digits are 57, which are common with the first two digits of N,but the next digit is D, the value corresponding to the Dth column. If there are more nodes with the prefix 57D, the closest one, according to the proximitymetric, is chosen, and its identifier is inserted in this cell. The proximity metric is a measurement of closeness determined by the application thatuses the network. It can be based on the number of hops between the two nodes, the round-trip timebetween the two nodes, or other metrics.  || Unit 2 - 61```",
            "```\fPastry - RoutingLeaf SetAnother entity used in routing is a set of 2b identifiers (the size of a row in therouting table) called the leaf set. The left half of the set is a list of IDs that are numerically smaller than thecurrent node IDThe right half is a list of IDs that are numerically larger than the current node ID. The leaf set gives the identifier of 2b-1 live nodes located before the current nodein the ring and the list of 2b-1 nodes located after the current node in the ring.  || Unit 2 - 62```",
            "```\fRouting table & Leaf Set, ExampleK3222N0002K3133K3122Node ID 22102200 2203 2213 2230Leaf set31220 0202 12121 2013 210322302 22032213Routing tableN32002013 2103 2203 2210Leaf set31220 0202 11031 2013 2103221022302203Routing tableN0101N0202N3122K0203N0301N0302N0321K2233Node ID 2200Node ID 0302m=80202 0301 0321 1000Leaf set1302 2001 31220002 0101 020203210301Routing tableN1000b=2N2230N1103N2213N2210N2203N2200N2103K1110N1212N1220N2013K1213N2001N1302K2011Node ID 20011220 1302 2013 2103Leaf set32000 0101 10002103 22002013Routing table || Unit 2 - 63```",
            "```\fPastry – Lookup OperationPastry - lookup: given a key, it finds the node that stores the information about thekey or the key itself. Lookup (key)if (key is in the range of N's leaf set)forward the message to the closest node in the leaf setelseroute (key, Table)route (key, Table)p = length of shared prefix between key and Nv = value of the digit at position p of the key// Position starts from 0if (Table [p, v] exists)forward the message to the node in Table [p, v]elseforward the message to a node sharing a prefix as long asthe current node, but numerically closer to the key.  || Unit 2 - 64```",
            "```\fLookup Operation, Example (1)K3222N0002N3200K3133K3122Node ID 22102200 2203 2213 2230Leaf set31220 0202 12121 2013 210322302 22032213Routing table(2) Ask 2013about key20112013 2103 2203 2210Leaf set31220 0202 11031 2013 2103221022302203Routing tableN0101N0202N3122K0203N0301N0302N0321K2233Node ID 2200Node ID 0302m=8N2230N2213N1000b=2N1103(1) Who’sresponsiblefor key 2011N2210N2203N2200N2103K1110N1212N1220N2013K1213N2001N1302K2011(3) Yes, Ihave the key20110202 0301 0321 1000Leaf set1302 2001 31220002 0101 020203210301Routing tableNode ID 20011220 1302 2013 2103Leaf set32000 0101 10002103 22002013Routing table || Unit 2 - 65```",
            "```\fLookup Operation, Example (2)(3) Yes, Ihave the key0203(1) Who’sresponsiblefor key 0203(2) Ask 0202about key0203 || Unit 2 - 66```",
            "```\fPastry – Join OperationThe process of joining the ring in Pastry is as follows:The new node, X, should know at least one node N0, which should be close to X, andsend a join message to it.  (we assume that N0 has no common prefix with X)1.  Node N0 sends the contents of its row 0 to node X.  Since the two nodes have nocommon prefix, node X uses the appropriate parts of this information to build its row 0. 2.  Node N0 call a lookup operation with X’s ID as a key, which will forward the joinmessage to a node, N1, whose identifier is closest to X. 3.  Node N1 sends the contents of its row 1 to node X.  Since the two nodes have onecommon prefix. 4.  Node N1 then call a lookup operation with X’s ID as a key, which will forward the joinmessage to a node, N2, whose identifier is closest to X. 5.  The process continues until the routing table of node X is complete. 6.  The last node in the process, which has the longest common prefix with X, also sends itsleaf set to node X, which becomes the leaf set of X.  || Unit 2 - 67```",
            "```\fJoin Operation, Example2212joinN00302Row 0join2001Row 1join2200Row 2join2210Row 3Node ID 22122200 2203 2213 2230Leaf set13023122210322302213Routing tableLeaf setA new node X with node ID N2212 uses the information in four nodes as shown to create itsinitial routing table and leaf set for joining the ring. We assume that node 0302 is a nearby node to node 2212 based on the proximity metric.  || Unit 2 - 68```",
            "```\fPastry – Leave (or Fail) OperationEach Pastry node periodically tests the liveliness of the nodes in its leaf set androuting table by exchanging probe messages. If a local node finds that a node in its leaf set is not responding to the probemessage, it assumes that the node has failed or departed. The local node then contacts the live node in its leaf set with the largest identifierand repairs its leaf set with the information in the leaf set of that node. If a local node finds that a node in its routing table, Table [i, j], is not responsive tothe probe message, it sends a message to a live node in the same row and requeststhe identifier in Table [i, j] of that node. This identifier replaces the failed or departed node.  || Unit 2 - 69```",
            "```\fKademliaKademlia, is a DHT peer-to-peer network that is designed by Petar Maymounkov andDavid Mazires, in 2002. Kademlia routes messages based on the distance between nodes. The distance between the two identifiers (nodes or keys) is measured as the bitwiseexclusive-or (XOR) between them. For instance, if x and y are two identifiers, the distance between them is defined as:distance (x, y) = x  yThis distance function has the following properties:xx=0The distance between a node and itself is zero. x  y > 0 if x ≠ yThe distance between any two distinct nodes is greater than zero. xy=yxThe distance between x and y is the same as between y and x. x  z ≤ x  y + y  z Triangular relationship is satisfied.  || Unit 2 - 70```",
            "```\fKademlia – Identifier spaceNodes and data items are m-bit identifiers that create an identifier space of 2m pointsdistributed on the leaves of a binary tree. The protocol uses the SHA-1 hashing algorithm with m = 160. For example: if m = 4, we have 16 IDs distributed on the leaves of a binary tree as:11110000N0N3 K3 K4N1N5N6K7 N8K9N11K12N15Tree rootN0N1N3 K3K4N5N6K7N8K9N11K12N15k3 is stored in N3 because 3  3 = 0.  k7 is stored in N6 not in N8 because 6  7 = 1 but7  8 = 15.  k12 is stored in N15 not in N11 because 11  12 = 7, but 12  15 = 3.  || Unit 2 - 71```",
            "```\fKademlia – Routing tableKademlia keeps only one routing table for each node; there is no leaf set. Each node N divides the binary tree into m subtrees. A subtree i includes nodes that share i leftmost bits (common prefix P) with the anode N, and does not include the node N itself. For example, the node N5 divides our previous tree as follows:P1P3P2P00101 || Unit 2 - 72```",
            "```\fKademlia – Routing tableRouting TableThe routing table is made of m rows but only one column, as follows. Commonprefix lengthIdentifiersClosest node(s) in subtree with common prefix of length 0Closest node(s) in subtree with common prefix of length 1Closest node(s) in subtree with common prefix of length 2m -1Closest node(s) in subtree with common prefix of length m - 1The idea is the same as that used by Pastry, but the length of the common prefix is basedon the number of bits instead of the number of digits in base 2b || Unit 2 - 73```",
            "```\fRouting Table, ExampleLet us find the routing table for our previous Example.  To make the example simple, we assumethat each row uses only one identifier. P3P2To updaterow 20000N8N5N3N1N0To updaterow 0To updaterow 1To updaterow 3Node N0P0P1N8 is theclosest nodeto N0N5 is theclosest nodeto N0N1N3 K3K4N5N6K7N8K9N11K12N15 || Unit 2 - 74```",
            "```\fRouting Table, ExampleLet us find the routing table for our previous Example.  To make the example simple, we assumethat each row uses only one identifier. P3P2P0P10001Node N0N8N5N3N1N0Node N1N1N8N5N3N0N3 K3K4N5N6K7N8K9N11K12N15 || Unit 2 - 75```",
            "```\fRouting Table, ExampleLet us find the routing table for our previous Example.  To make the example simple, we assumethat each row uses only one identifier. P2P3P0P10011Node N0N8N5N3N1N0Node N1N1N8N5N3N0Node N30 N111 N62 N1N3 K3K4N5N6K7N8K9N11K12N15 || Unit 2 - 76```",
            "```\fRouting Table, ExampleLet us find the routing table for our previous Example.  To make the example simple, we assumethat each row uses only one identifier. P3P1P2P00101Node N0N8N5N3N1N0Node N1N1N8N5N3N0Node N3Node N50 N111 N62 N10 N151 N12 N6N3 K3K4N5N6K7N8K9N11K12N15 || Unit 2 - 77```",
            "```\fRouting Table, ExampleLet us find the routing table for our previous Example.  To make the example simple, we assumethat each row uses only one identifier. P2P1P3P00111Node N0N8N5N3N1N0Node N1N1N8N5N3N0Node N3Node N5Node N60 N111 N62 N10 N151 N12 N60 N151 N32 N5N3 K3K4N5N6K7N8K9N11K12N15 || Unit 2 - 78```",
            "```\fRouting Table, ExampleLet us find the routing table for our previous Example.  To make the example simple, we assumethat each row uses only one identifier. P0P3P2P11000Node N0N8N5N3N1N0Node N1N1N8N5N3N0Node N3Node N5Node N6Node N80 N111 N62 N10 N151 N12 N60 N151 N32 N50 N01 N152 N11N3 K3K4N5N6K7N8K9N11K12N15 || Unit 2 - 79```",
            "```\fRouting Table, ExampleLet us find the routing table for our previous Example.  To make the example simple, we assumethat each row uses only one identifier. P0P2P3P11011Node N0N8N5N3N1N0Node N1N1N8N5N3N0Node N3Node N5Node N6Node N8Node N110 N111 N62 N10 N151 N12 N60 N151 N32 N50 N01 N152 N110 N31 N152 N8N3 K3K4N5N6K7N8K9N11K12N15 || Unit 2 - 80```",
            "```\fRouting Table, ExampleLet us find the routing table for our previous Example.  To make the example simple, we assumethat each row uses only one identifier. P0P2P1P31111Node N0N8N5N3N1N0Node N1N1N8N5N3N0Node N3Node N5Node N6Node N8Node N11Node N150 N111 N62 N10 N151 N12 N60 N151 N32 N50 N01 N152 N110 N31 N152 N80 N61 N11N3 K3K4N5N6K7N8K9N11K12N15 || Unit 2 - 81```",
            "```\fLookup Operation, Example (1)We assume node N0 (0000)2 receives a lookup message to find the node responsible for k12(1100)2. Node N0N8N5N3N1N00000(1) Who’sresponsible forkey K12 (1100)Node N1N8N5N3N0Node N3Node N5Node N6Node N8Node N11Node N150 N111 N62 N10 N151 N12 N60 N151 N32 N50 N01 N152 N110 N31 N152 N80 N61 N11N3 K30011N10001(2) AskN8 aboutK12K4N50101N60110K7N81000K9(3) AskN15 aboutK12N111011K12N151111(4) Yes, Ihave the keyK12 (1100)The length of the common prefix between the N0 and K12 is 0.  N0 sends the message to thenode in row 0 of its routing table, node N8. In N8, the length of the common prefix is 1.  It checks row1 and send the query to N15, which isresponsible for k12. The routing process is terminated.  The route is N0 → N8 → N15.  || Unit 2 - 82```",
            "```\fLookup Operation, Example (2)We assume node N5 (0101)2 receives a lookup message to find the node responsible for k7(0111)2. Node N0N8N5N3N1N00000Node N1N8N5N3N0Node N3Node N5Node N6Node N8Node N11Node N150 N111 N62 N10 N151 N12 N60 N151 N32 N50 N01 N152 N110 N31 N152 N80 N61 N11N3 K30011N10001(2) AskN6 aboutK7K4N50101(1) Who’sresponsible forkey K7 (0111)N60110K7N81000K9N111011K12N151111(3) Yes, Ihave the keyK7 (0111)The length of the common prefix between the N5 and K7 is 2.  N5 sends the message to the nodein row 2 of its routing table, node N6, which is responsible for k7. The routing process is terminated.  The route is N5 → N6.  || Unit 2 - 83```",
            "```\fLookup Operation, Example (3)We assume node N11 (1011)2 receives a lookup message to find the node responsible for k4(0100)2. Node N0N8N5N3N1N00000Node N1N8N5N3N0N10001Node N3Node N5Node N6Node N8Node N11Node N150 N111 N62 N10 N151 N12 N60 N151 N32 N50 N01 N152 N110 N31 N152 N80 N61 N11(3) AskN6 aboutK4N3 K30011K4N50101(5) Yes, Ihave the keyK4 (0100)N60110K7(4) AskN5 aboutK4N81000K9(2) AskN3 aboutK4N111011K12N151111(1) Who’sresponsible forkey K4 (0100)The length of the common prefix between the N11 and K4 is 0. N11 sends the message to the node in row 0 of its routing table, node N3. In N3, The length of the common prefix between the two identifiers is 1, the message sent to N6. In N6, The length of the common prefix between the two identifiers is 2, the message sent to N5,which is responsible for k4. The routing process is terminated.  The route is N11 → N3 → N6 → N5.  || Unit 2 - 84```",
            "```\fKademlia – K-BucketsFor more efficiency, Kademlia requires that each row in the routing table keeps atleast up to K=20 nodes from the corresponding subtree. For this reason, each row in the routing table is referred to as a k-bucket. Having more than one node in each row allows the node to use an alternative nodewhen a node leaves the network or fails. Kademlia keeps those nodes in a bucket that has been connected in the network fora long time.  || Unit 2 - 85```",
            "```\fKademlia – More operationsJoin operationAs in Pastry, a node that needs to join the network needs to know at least oneother node. The joining node sends its identifier to the node as though it is a key to befound.  The response it receives allows the new node to create its k-buckets. Leave operationWhen a node leaves the network or fails, other nodes update their k-bucketsusing the lookup process.  || Unit 2 - 86```",
            "```\fChordChord was published by Stoica et al.  in 2001. Chord uses m-bit number to identify the data items denoted as k (for key) and toidentify the peers denoted as N (for node).  . The identifier space then of size 2m points distributed in a circle in the clockwisedirection. All arithmetic in the identifier space is done modulo 2m. Chord recommends the cryptographic hash function SHA-1 for the identifier spacegeneration.  SHA-1 produces output of fixed length equal to 160 bits. The closest peer with N ≥ k is called the successor of k and hosts the value (k, v). where, k is the key (hash of the data name) and v is the value (informationabout the peer that has the actual object).  || Unit 2 - 87```",
            "```\fChord – Finger tableAny node should be able to resolve a query/lookup that asks for the node identifierresponsible for a given key. If a node has no information about this key it forward the query to another nodethat may know. To do forwarding, each node needs to know about m successors nodes and onepredecessor node. These information are saved in a routing table called Finger table. A Finger tableof the node NTarget keySuccessor of target keyInformation about successorN+1Successor of N+1IP address and port of successorN+2Successor of N+2IP address and port of successorN+4Successor of N+4IP address and port of successorN + 2i-1Successor of N + 2i-1IP address and port of successor || Unit 2 - 88```",
            "```\fFinger table - exampleConsider a ring with few nodes and m=5, to make the example simpler. We show only the successor columnfrom the Finger table for and keys. Pre: N25K31Pre: N201 N52 N53 N54 N55 N10K4N25FingerPre: PredecessorFinger[1]: SuccessorN20Pre: N121 N252 N253 N254 N55 N5FingerFingerN5K26N10N10N10N20N25Pre: N5K7K9N10N12K16N12N12N20N20N5FingerK14Note that:• N5 is responsible forK26, K31, K4. • N10 is responsiblefor K7, K9. • N20 is responsiblefor K14, K16. Pre: N10N20N20N20N20N5FingerLegendkey = hash (object name)node = hash (IP address)point (potential key or node) || Unit 2 - 89```",
            "```\fChord – Lookup OperationIn Chord, the lookup operation is used to find where an object is located among theavailable peers in the ring. To find the object, a peer need to know the node that is responsible for that object(the peer that stores reference to that object). We know that, a peer that is the successor of a set of keys in the ring is theresponsible peer for those keys. Finding the responsible node is actually finding the successor of a key. To find the successor of a key, the lookup operationfirst find the predecessor of the key (using find_predecessor function), andthen from the predecessor node it finds the next node in the ring which is thevalue of “finger [1]”. If the key is located far from the current node, the node needs the help of othernodes to find the predecessor (using find_closest_predecessor function). Next slide shows the code for the lookup operation.  || Unit 2 - 90```",
            "```\fChord – Lookup OperationsWho’sresponsiblefor key K14Lookup (key)if (the current node N is responsible for the key)return (N’s ID)elsereturn find_successor (key)find_successor (id)x= find_ predecessor (id)return x. finger[1]find_predecessor (id) {x= Nwhile (id  (x, x. finger[1]) {x = x. find_closest_predecessor (id)return xfind_closest_predecessor (id) {for (i = m downto 1) {if (finger [i]  (N, id))return (finger [i])return N// N is the current node// Let x find it//N is the current node//The node itself is closest predecessor || Unit 2 - 91```",
            "```\fChord – Stabilize OperationLeaving and Joining of a node or a group of nodes may destabilize the ring. Chord defines an operation called stabilize to address this issue so that:Each node in the ring periodically uses stabilizeto validate its information about its successor andlet the successor validate its information about its predecessor. In other words,1.  Node N uses the value of finger[1], S, to ask node S to return its predecessor, P. 2.  If the return value, P, from this query is between N and S, this means that thereis a node with ID equals P that lies between N and S. 3.  Then node N makes P its successor and notifies P to make node N itspredecessor || Unit 2 - 92```",
            "```\fChord – Stabilize OperationStabilize ( )P= finger[1]. Pre//Ask the successor to return its predecessorif(P  (N, finger[1]))finger[1] =Pfinger[1]. notify (N)// P is the possible successor of N// Notify P to change its predecessorNotify (x)if (Pre = null or x  (Pre, N))Pre = x || Unit 2 - 93```",
            "```\fChord – Fix_Finger OperationDestabilization may change the finger table of up to m nodes. Chord defines a fix_finger function to update its finger tables. Each node in the ring must periodically call this function. To avoid traffic on the system, each node must only update one of its fingers in eachcall.  This finger is chosen randomly. Fix_Finger ()Generate (i  (1, m])finger[i] =find_successor (N + 2// Randomly generate i such that 1< i ≤ mi– 1)// Find value of finger[i] || Unit 2 - 94```",
            "```\fChord – Join OperationWhen a new node (N) joins the ring, it uses the join operation. Join function needs to know an ID of another node (say x) to find the successor ofthe new node and set its predecessor to null. It immediately calls the stabilize function to validate its successor. The new node then asks the successor to call the move-key function that transfersthe keys that the new node is responsible for. Join (x)Initialize (x)finger[1]. Move_Keys (N)Initialize (x)Pre = nullif (x = null) finger[1] = Nelse finger[1] = x.  Find_Successor (N)Move_Keys (x)for (each key k)if (x  [k, N)) move (k to node x)// N is the current nodeNote that, after this operation, the finger table ofthe new (joined) node is empty and the finger tableof up to m predecessors is out of date. The stabilize and the fix-finger operations that runperiodically after this event will gradually stabilizethe system.  || Unit 2 - 95```",
            "```\fJoin Operation - ExamplePre: N201 N52 N53 N54 N55 N10FingerN17N17Pre: N121 N252 N253 N254 N55 N5Finger1.  N17 needs to join with the help of N5. 2.  N17 uses Initialize (5) – to set its predecessor to null and itssuccessor (finger[1]) to N20. 3.  N17 then asks N20 to send k14 and k16 to N17 because N17 is nowresponsible for these keys4.  N17 uses stabilize to asks N20 to change its predecessor to N175.  When N12 uses stabilize, the predecessor of N17 is updated to N126.  Finally, when some nodes use fix-finger, the finger table of nodesN17, N10, N5, and N12 is changedPre: N25K31K4N5K26N25Pre: PredecessorFinger[1]: SuccessorK22N20N12Pre: nullN20N25N25N05N10N10N10N20N25N17Pre: N5FingerN17K9N10N12N17 K16 K141 N20K7N12N12N20N20N5FingerPre: N10N20N20N20N20N5N17N17N17FingerFinger || Unit 2 - 96```",
            "```\fChord – Leave (or Fail) OperationWhen a peer leaves the ring or the peer fails, the status of the ring will be disruptedunless the ring stabilizes itself. Each node exchanges ping and pong messages with neighbours to find out if they arealive. When a node does not receive a pong message in response to its ping message, thenode knows that the neighbour is dead. The node that detects the problem can immediately launch these stabilize and fixfinger operations. Note that, the data managed by the node that left or failed is no longer available. Therefore, Chord requires that data and references be duplicated on othernodes.  || Unit 2 - 97```",
            "```\fLeave Operation - ExampleN12N12N12To leaveN12N51.  Node N5 finds out about N10's departure when it does not receive apong message to its ping message. 2.  Node N5 changes its successor (finger[1]) to N12. 3.  Node N5 immediately launches the stabilize function and asks N12 tochange its predecessor to N5. 4.  Hopefully, k7 and k9, which were under the responsibility of N10,have been duplicated in N12 before the departure of N10. 5.  After a few calls of fix-finger, nodes N5 and N25 update their fingertables as shown in the figure.  || Unit 2 - 98```"
        ]
    },
    {
        "pptName": "Unit 3",
        "slides": [
            "```\fUnit 3Software-Defined Networking(SDN) || Unit 3 - 2```",
            "```\fUnit 3: Software-Defined Networking3. 1 The limitations of the traditional network architectures. 3. 2 The key requirements for an SDN architecture. 3. 3 The functions of the SDN data plane. 3. 4 The OpenFlow logical architecture and network protocol. 3. 5 The functions of the SDN control plane. 3. 6 An overview of OpenDaylight and REST APIs. 3. 7 An overview of the SDN application plane architecture. Reading: https://www. opennetworking. org/sdn-definition/ || Unit 3 - 3```",
            "```\f3. 1 The limitations of the traditional networkarchitectures || Unit 3 - 4```",
            "```\fEvolving Network RequirementsA number of trends are driving network providers and users toreevaluate traditional approaches to network architecture. These trends can be grouped under the categories ofdemand,Due to the increase in Cloud Computing, Big Data, Mobile traffic,IoT, etc. supply,Due to the increase in the capacity of the network transmissiontechnologies (e. g. , Ethernet, WiFi, 5G)traffic patterns.  || Unit 3 - 5```",
            "```\fSo …Traditional Network Architectures areInadequate!Why? || Unit 3 - 6```",
            "```\fTraditional Network Architectures are InadequateThe traditional internetworking approach is based on the TCP/IPprotocol architecture. Three significant characteristics of this approach are as follows:Two-level end system addressingRouting based on destinationDistributed autonomous control || Unit 3 - 7```",
            "```\fLimitationsThe Open Networking Foundation (ONF) cites four generallimitations of traditional network architectures:Static, complex architectureInconsistent policiesInability to scaleVendor dependence || Unit 3 - 8```",
            "```\f3. 2 The key requirements for an SDNarchitecture || Unit 3 - 9```",
            "```\fThe principal requirements for a modern networkingAdaptabilityNetworks must adjust and respond dynamically, based onapplication needs, business policy, and network conditions. AutomationPolicy changes must be automatically propagated so thatmanual work and errors can be reduced. MaintainabilityIntroduction of new features and capabilities (software upgrades,patches) must be seamless with minimal disruption of operations. Model managementNetwork management software must allow management of thenetwork at a model level, rather than implementing conceptualchanges by reconfiguring individual network elements. MobilityControl functionality must accommodate mobility, including mobileuser devices and virtual servers. Integrated securityNetwork applications must integrate seamless security as a coreservice instead of as an add-on solution. On-demand scalingImplementations must have the ability to scale up or scale downthe network and its services to support on-demand requests.  || Unit 3 - 10```",
            "```\fSDN and NFVTo provide adaptability and scalability, two key technologies that arerapidly being deployed by a variety of network service andapplication providers are:software-defined networking (SDN)Discussed in the subsequent slidesnetwork functions virtualization (NFV)Will be covered in SE4455 || Unit 3 - 11```",
            "```\fSoftware-defined networking (SDN)SDN is replacing the traditional networking model, it provides anenhanced level of flexibility to meet the needs of newer networkingand IT trends such as cloud, mobility, social networking, and video. In SDN, there are two elements involved in forwarding packetsthrough routersa control function, whichdecides the route for the flow totake and the relative priorityof traffic,and a data function, whichforwards data based oncontrol-function policy.  || Unit 3 - 12```",
            "```\fThe traditional network Vs.  the SDN approaches || Unit 3 - 13```",
            "```\fThe SDN approach || Unit 3 - 14```",
            "```\fThe SDN approach - The data planeThe data plane consists of physical switches and virtual switches,which are responsible for forwarding packets. The internal implementation of buffers, priority parameters, andother data structures should be uniform and open to the SDNcontrollers. This can be defined in terms of an open application programminginterface (API) between the control plane and the data plane(southbound API). The most prominent example of such an open API is OpenFlow.  || Unit 3 - 15```",
            "```\fThe SDN approach - The control planeSDN controllers can be implemented directly on a server or on avirtual server. OpenFlow or some other open API is used to control the switches inthe data plane. In addition, controllers use information about capacity and demandobtained from the networking equipment through which the trafficflows. SDN controllers also expose northbound APIs, which allowdevelopers and network managers to deploy a wide range of offthe-shelf and custom-built network applications. A number of vendors offer a Representational State Transfer(REST)-based API to provide a programmable interface to their SDNcontroller.  || Unit 3 - 16```",
            "```\fThe SDN approach - The application planeAt the application plane are a variety of applications that interactwith SDN controllers. SDN applications are programs that may use an abstract view of thenetwork for their decision-making goals. These applications convey their network requirements and desirednetwork behavior to the SDN controller via a northbound API. Examples of applications areenergy-efficient networking,security monitoring,access control, andnetwork management.  || Unit 3 - 17```",
            "```\fCharacteristics of SDNThe control plane is separated from the data plane; data planedevices become simple packet-forwarding devices. The control plane is implemented in a centralized controller or set ofcoordinated centralized controllers. The SDN controller has a centralized view of the network ornetworks under its control. The controller is portable software that can run on servers and iscapable of programming the forwarding devices based on acentralized view of the network. The network is programmable by applications running on top of theSDN controllers; the SDN controllers present an abstract view ofnetwork resources to the applications.  || Unit 3 - 18```",
            "```\fStandards-Developing OrganizationsUnlike some technology areas, such as Wi-Fi, there is no singlestandards body responsible for developing open standards for SDNand NFV. Rather, there is a large and evolving collection of standardsdeveloping organizations (SDOs), industrial consortia, and opendevelopment initiatives involved in creating standards and guidelinesfor SDN and NFV. The following table lists the main SDOs and other organizationsinvolved in the effort and the main outcomes so far produced.  || Unit 3 - 19```",
            "```\fSDN and NFVStandardsActivities || Unit 3 - 20```",
            "```\fOpenDaylightAn open source software activity under the auspices of the LinuxfoundationIts member companies provide resources to develop an SDNcontroller for a wide range of applicationsIs more in the nature of an open development initiative than aconsortiumAlso supports network programmability via southbound protocols, abunch of programmable network services, a collection ofnorthbound APIs, and a set of applications || Unit 3 - 21```",
            "```\fOpenStackIs an open source software project that aims to produce an opensource cloud operating systemProvides multitenant Infrastructure as a Service (IaaS) and aims tomeet the needs of public and private clouds regardless of size, bybeing simple to implement and massively scalableSDN technology is expected to contribute to its networking part,and to make the cloud operating system more efficient, flexible, andreliable || Unit 3 - 22```",
            "```\f3. 3 The functions of the SDN data plane || Unit 3 - 23```",
            "```\fThe SDN data planeReferred to as the resource layer or as the infrastructure layer,where network forwarding devices perform the transport andprocessing of data according todecisions made by the SDNcontrol plane. The important characteristic ofthe network devices in an SDNnetwork is that these devicesperform a simple forwardingfunction, without embeddedsoftware to make autonomousdecisions. The data plane network devicesalso called data plane networkelements or switches.  || Unit 3 - 24```",
            "```\fA simple forwarding function || Unit 3 - 25```",
            "```\fA simple forwarding functionThe principal functions of the network device are the following:Control support function: Interacts with the SDN control layer tosupport programmability via resource-control interfaces.  The switchcommunicates with the controller and the controller manages the switchvia the OpenFlow switch protocol. Data forwarding function: Accepts incoming data flows from othernetwork devices and forwards them along the data forwarding pathsthat have been computed and established by the SDN controlleraccording to the rules defined by the SDN applications. The network device can alter the packet header before forwarding,or discard the packet.  As shown, arriving packets may be placed inan input queue, awaiting processing by the network device, andforwarded packets are generally placed in an output queue,awaiting transmission.  || Unit 3 - 26```",
            "```\f3. 4 The OpenFlow logical architecture andnetwork protocol || Unit 3 - 27```",
            "```\fThe OpenFlowThere must be acommon logicalarchitecture in allnetwork devices to bemanaged by an SDNcontroller.  The SDNcontroller should see auniform logical switchfunctionalityA standard, secureprotocol is neededbetween the SDNcontroller and thenetwork device.  || Unit 3 - 28```",
            "```\fThe OpenFlowOpenFlow is both a protocol between SDN controllers and networkdevices and a specification of the logical structure of the networkswitch functionality.  || Unit 3 - 29```",
            "```\fThe OpenFlowOpenFlow is defined in the OpenFlow Switch Specification, publishedby the Open Networking Foundation (ONF). An SDN controller communicates with OpenFlow-compatibleswitches using the OpenFlow protocol running over TransportLayer Security (TLS). Each switch connects to other OpenFlow switches and, possibly, toend-user devices that are the sources and destinations of packetflows. On the switch side, the interface is known as an OpenFlowchannel.  These connections are via OpenFlow ports. An OpenFlow port also connects the switch to the SDN controller.  || Unit 3 - 30```",
            "```\fThe OpenFlow – Switch portsOpenFlow defines three types of ports:Physical port: Corresponds to a hardware interface of the switch.  Forexample, an Ethernet switch. Logical port: Does not correspond directly to a hardware interface ofthe switch.  May be defined in the switch using non-OpenFlow methods(for example, link aggregation groups, tunnels, loopback interfaces) andmay map to various physical ports. Reserved port: It specifies generic forwarding actions such as sendingto and receiving from the controller, flooding, or forwarding using nonOpenFlow methods, such as “normal” switch processing.  || Unit 3 - 31```",
            "```\fThe OpenFlow – TablesThe OpenFlow defines three types of tables:A flow table: matches incoming packets to a particular flow andspecifies what functions are to be performed on the packets.  There maybe multiple flow tables that operate in a pipeline fashion, as explainedsubsequently. A Group table: a flow table may direct a flow to a group table, whichmay trigger a variety of actions that affect one or more flows. A meter table: consists of meter entries that can trigger a variety ofperformance-related actions on a flow. Using the OpenFlow switch protocol, the controller can add, update,and delete flow entries in tables, both reactively (in response topackets) and proactively.  || Unit 3 - 32```",
            "```\fThe flow table(s)Each packet that enters an OpenFlow switch passes through one of moreflow tables.  Each flow table consists of a number of rows, called entries,consisting of seven components.  || Unit 3 - 33```",
            "```\fThe flow table – Seven ComponentsMatch fieldsUsed to select packets that match the values in the fields. PriorityRelative priority of table entries.  This is a 16-bit field with 0corresponding to the lowest priority.  In principle, there could be216 = 64k priority levels. CountersUpdated for matching packets.  The OpenFlow specification definesa variety of countersInstructionsInstructions to be performed if a match occursTimeoutsMaximum amount of idle time before a flow is expired by theswitch. Cookie64-bit data value chosen by the controller.  May be used by thecontroller to filter flow statistics, flow modification and flowdeletion; not used when processing packets. FlagsFlags alter the way flow entries are managed; for example, theflag OFPFF_SEND_FLOW_REM triggers flow removed messagesfor that flow entry.  || Unit 3 - 34```",
            "```\fThe flow table – The match fields componentIngress portThe identifier of the port on this switch on which thepacket arrived.  This may be a physical port or aswitch-defined virtual port.  Required in ingress tables. Egress portThe identifier of the egress port from action set. Required in egress tables. Ethernet source anddestination addressesEach entry can be an exact address, a bit maskedvalue for which only some of the address bits arechecked, or a wildcard value. Ethernet type fieldIndicates type of the Ethernet packet payload. IPVersion 4 or 6. IPv4 or IPv6 source address,and destination addressEach entry can be an exact address, a bit maskedvalue, a subnet mask value, or a wildcard value. TCP source and destinationportsExact match or wildcard value. UDP source and destinationportsExact match or wildcard value || Unit 3 - 35```",
            "```\fThe flow table – The countersCounterUsageReference Count (active entries)Per Flow Table32Duration (seconds)Per Flow Entry32Received PacketsPer Port64Transmitted PacketsPer Port64Duration (seconds)Per Port32Transmit PacketsPer Queue64Duration (seconds)Per Queue32Duration (seconds)Per Group32Duration (seconds)Per Meter32Bit length || Unit 3 - 36```",
            "```\fPacket flow through the processing pipelineA switch includes one or more flow tables.  If there is more than oneflow table, they are organized as a pipeline, with the tables labeledwith increasing numbers starting with zero. The use of multiple tables in a pipeline, rather than a single flowtable, provides the SDN controller with considerable flexibilityThe OpenFlow specification defines two stages of processing:Ingress processingEgress processing || Unit 3 - 37```",
            "```\fIngress processing alwayshappens, beginning with Table0, and uses the identity of theinput port.  Table 0 may be theonly table, in which case theingress processing is simplifiedto the processing performed onthat single table, and there isno egress processing. Egress processing is theprocessing that happens afterthe determination of the outputport.  It happens in the contextof the output port.  This stage isoptional.  If it occurs, it mayinvolve one or more tables.  || Unit 3 - 38```",
            "```\fThe ingress processingAt the final table in thepipeline forwarding toanother flow table is notan option. If and when a packet isfinally directed to anoutput port, theaccumulated action setis executed and thenthe packet is queued foroutput.  || Unit 3 - 39```",
            "```\fThe egress processingIf egress processing isassociated with aparticular output port,then after a packet isdirected to an outputport in the ingressprocess, the packet isdirected to the first flowtable of the egresspipelineThere is no group tableprocessing at the end ofthe egress pipeline.  || Unit 3 - 40```",
            "```\fThe use of multiple tablesThe use of multiple tables enables the breaking down of a single flow into anumber of parallel subflows. The use of multiple tables simplifies the processing in both the SDN controller andthe OpenFlow switch. Actions such as next hop that apply to the aggregate flow can be defined once by thecontroller and examined and performed once by the switch.  The addition of newsubflows at any level involves less setup. Therefore, the use of pipelined, multiple tables increases the efficiency of networkoperations, provides granular control, and enables the network to respond to realtime changes at the application, user, and session levels.  || Unit 3 - 41```",
            "```\fThe Group TablesDuring the pipeline processing, a flow table may direct a flow ofpackets to the group table rather than another flow table. The group table and group actions enable OpenFlow to represent aset of ports as a single entity for forwarding packets. Different types of groups are provided to represent differentforwarding abstractions, such as multicasting and broadcasting. Each group table consists of a number of rows, called group entries,consisting of four components.  || Unit 3 - 42```",
            "```\fThe Group TablesGroup identifier: A 32-bit unsigned integer uniquely identifying thegroup.  A group is defined as an entry in the group table. Group type: Determines group semantics, explained in the next slide. Counters: Updated when packets are processed by a group. Action buckets: An ordered list of action buckets, where each actionbucket contains a set of actions to execute. The action list is executed in sequence and generally ends with theOutput action, which forwards the packet to a specified port. The action list may also end with the Group action, which sends thepacket to another group.  || Unit 3 - 43```",
            "```\fThe Group Tables – Group TypeA group is designated as all, select, fast Failover, or indirect. all: executes all the buckets in the group. Each arriving packet is effectively cloned. Each bucket will designate a different output port, so that the incomingpacket is then transmitted on multiple output ports. This group is used for multicast or broadcast forwarding.  || Unit 3 - 44```",
            "```\fThe Group Tables – Group Typeselect:Executes one bucket in the group, based on a switch-computedselection algorithm (for example, hash on some user-configured tupleor simple round robin). The selection algorithm should implement equal load sharing or,optionally, load sharing based on bucket weights assigned by the SDNcontroller.  || Unit 3 - 45```",
            "```\fThe Group Tables – Group Typefast failover:Executes the first live bucket. Port liveness is managed by code outsideof the scope of OpenFlow and may have todo with routing algorithms. The buckets are evaluated in order, andthe first live bucket is selected. This group type enables the switch tochange forwarding without requiring around trip to the controller.  || Unit 3 - 46```",
            "```\fThe Group Tables – Group Typeindirect:Allows multiple packet flows (that is, multiple flowtable entries) to point to a common group identifier. This type provides for more efficient management bythe controller in certain situations. For example, suppose that there are 100 flow entries thathave the same match value in the IPv4 destination addressmatch field, but differ in some other match field, but all ofthem forward the packet to port X by including the actionOutput X on the action list.  We can instead replace thisaction with the action Group GID, where GID is the ID of anindirect group entry that forwards the packet to port X.  Ifthe SDN controller needs to change from port X to port Y, itis not necessary to update all 100 flow table entries.  All thatis required is to update the group entry.  || Unit 3 - 47```",
            "```\fOpenFlow ProtocolThe OpenFlow protocol describes message exchanges that take placebetween an OpenFlow controller and an OpenFlow switchTypically, the protocol is implemented on top of TLS, providing a secureOpenFlow channelThe OpenFlow protocol enables the controller to perform add, update, anddelete actions to the flow entries in the flow tablesIt supports three types of messages:Controller toswitchAsynchronousSymmetric || Unit 3 - 48```",
            "```\fOpenFlow MessagesMessageFeaturesConfigurationModify-StateRead-StatePacket-outBarrierRole-RequestAsynchronousConfigurationPacket-inFlow-RemovedPort-StatusRole-StatusController-StatusFlow-monitorHelloEchoErrorExperimenterDescriptionController-to-SwitchRequest the capabilities of a switch.  Switch responds with a features reply that specifies its capabilities. Set and query configuration parameters.  Switch responds with parameter settingsAdd, delete, and modify flow/group entries and set switch port properties. Collect information from switch, such as current configuration, statistics, and capabilities. Direct packet to a specified port on the switch. Barrier request/reply messages are used by the controller to ensure message dependencies have beenmet or to receive notifications for completed operations. Set or query role of the OpenFlow channel.  Useful when switch connects to multiple controllers. Set filter on asynchronous messages or query that filter.  Useful when switch connects to multiplecontrollers. AsynchronousTransfer packet to controller. Inform the controller about the removal of a flow entry from a flow table. Inform the controller of a change on a port. Inform controller of a change of its role for this switch from master controller to slave controller. Inform the controller when the status of an OpenFlow channel changes.  This can assist failover processingif controllers lose the ability to communicate among themselves. Inform the controller of a change in a flow table.  Allows a controller to monitor in real time the changes toany subsets of the flow table done by other controllersSymmetricExchanged between the switch and controller upon connection startup. Echo request/reply messages can be sent from either the switch or the controller, and must return anecho reply. Used by the switch or the controller to notify problems to the other side of the connection. For additional functionality.  || Unit 3 - 49```",
            "```\f3. 5 The functions of the SDN control plane || Unit 3 - 50```",
            "```\fSDN control plane architectureThe SDN control layer mapsapplication layer servicerequests into specificcommands and directives todata plane switches andsupplies applications withinformation about data planetopology and activity. The control layer isimplemented as a server orcooperating set of serversknown as SDN controllers. Let’s look at specific protocolsand standards implementedwithin the control plane || Unit 3 - 51```",
            "```\fSDN controllers functionsShortest path forwarding:Uses routing information collectedfrom switches to establish preferredroutes. Notification manager:Receives, processes, and forwardsan application events, such as alarmnotifications, security alerts, and state changes. Security mechanisms: Provides isolation and security enforcement betweenapplications and services. Topology manager: Builds and maintains switch interconnection topologyinformation. Statistics manager: Collects data on traffic through the switches. Device manager: Configures switch parameters and attributes and managesflow tables entries.  || Unit 3 - 52```",
            "```\fNetwork Operating System (NOS)The functionality provided by the SDN controller can be viewed as anetwork operating system (NOS)As with a conventional OS, NOS provides essential services,common application programming interfaces (APIs), and anabstraction of lower-layer elements to developersThe functions of an SDN NOS enable developers to define networkpolicies and manage networks without concern for the details of thenetwork device characteristicsNorthbound interfaces enable developers to create software thatis independent not only of data plane details but to a variety of SDNcontroller servers.  (more details later. . ) || Unit 3 - 53```",
            "```\fSDN controller implementationsA number of different initiatives, both commercial and open source,have resulted in SDN controller implementations:OpenDaylightOpen NetworkOperating System(ONOS)POXBeaconFloodlightRyuOnix || Unit 3 - 54```",
            "```\fSDN controller implementationsOpenDaylight: An open source platform for network programmability to enable SDN,written in Java.  OpenDaylight was founded by Cisco and IBM. Floodlight: An open source package developed by Big Switch Networks.  Both a webbased and Java based GUI are available and most of its functionality is exposed through aREST API. Open Network Operating System (ONOS): An open source SDN NOS, a nonprofiteffort funded and developed by a number of carriers, such as AT&T and NTT, and otherservice providers and supported by the Open Networking Foundation. Ryu: An open source component-based SDN framework developed by NTT Labs. Developed in python. POX: An open source OpenFlow controller that has been implemented by a number ofSDN developers and engineers.  POX has a well written API and documentation.  It alsoprovides a web-based graphical user interface (GUI) and is written in Python. Beacon: An open source package developed at Stanford.  Written in Java.  Beacon was thefirst controller that made it possible for beginner programmers to work with and create aworking SDN environment. Onix: Commercially available SDN controller, developed by VMWare, Google, and NTT.  || Unit 3 - 55```",
            "```\fSDN Controller InterfacesThe southbound interface provides the logicalconnection between the SDN controller andthe data plane switches. The most commonly implemented southboundAPI is OpenFlow. Other southbound interfaces include thefollowing:Open vSwitch Database Management Protocol(OVSDB): an open source software projectwhich implements virtual switching.  OVS usesOpenFlow for message forwarding in the controlplane for both virtual and physical ports. Forwarding and Control Element Separation(ForCES): An IETF effort that standardizes theinterface between the control plane and thedata plane for IP routers.  || Unit 3 - 56```",
            "```\fSDN Controller InterfacesThe northbound interface enables applications to access controlplane functions and services without needing to know the details ofthe underlying network switches. The northbound interface is more typically viewed as a software APIrather than a protocol. Base controller function APIs: These APIs expose the basicfunctions of the controller and are used by developers to createnetwork services. Network service APIs: These APIs expose network services to thenorth.  For example, Firewalls, Routings, and Optimizations. Northbound interface application APIs: These APIs exposeapplication-related services that are built on top of network services. For Example, security-related services.  || Unit 3 - 57```",
            "```\fSDN Controller - RoutingThe routing function comprises a protocol for collecting information aboutthe topology and traffic conditions of the network, and an algorithm fordesigning routes through the networkThere are two categories of routing protocols:• Concerned with discoveringthe topology of routerswithin an AS and thendetermining the best routeto each destination basedon different metricsInterior router protocols(IRPs) that operate withinan autonomous system (AS)Exterior router protocols(ERPs) that operate betweenautonomous systems• Need not collect as muchdetailed traffic information• Primary concern is todetermine reachability ofnetworks and end systemsoutside of the AS || Unit 3 - 58```",
            "```\fSDN Controller - RoutingTraditionally, the routing function is distributed among the routersin a network.  Each router is responsible for building up an image ofthe topology of the network.  For interior routing, each router as wellmust collect information about connectivity and delays and thencalculate the preferred route for each IP destination address. However, in an SDN-controlled network, the controller provides acentralized routing that can develop a consistent view of thenetwork state to calculate shortest paths. The data plane switches are relieved of the processing and storageburden associated with routing, leading to improved performance.  || Unit 3 - 59```",
            "```\fSDN Controller - RoutingThe centralized routing application performs two distinct functions:Link discoveryThe routing function needs to be aware of links between data planeswitchesMust be performed between a router and a host system and between arouter in the domain of this controller and a router in a neighboring domainDiscovery is triggered by unknown traffic entering the controller’s networkdomain either from an attached host or from a neighboring routerTopology managerMaintains the topology information for the network and calculates routes inthe networkRoute calculation involves determining the shortest path between two dataplane nodes or between a data plane node and a host || Unit 3 - 60```",
            "```\f3. 6 An overview of OpenDaylight and RESTAPIs || Unit 3 - 61```",
            "```\fThe OpenDaylight architecture || Unit 3 - 62```",
            "```\fService Abstraction Layer Model || Unit 3 - 63```",
            "```\fService Abstraction Layer ModelOpenDaylight is not tied to OpenFlow or any other specific southboundinterface.  This provides greater flexibility in constructing SDN networkconfigurations. The key element in this design is the SAL, which enables the controller tosupport multiple protocols on the southbound interface and provide consistentservices for controller functions and for SDN applications. The services manager maintains a registry that maps service requests to featurerequests.  Based on the service request, the SAL maps to the appropriate plug-inand thus uses the most appropriate southbound protocol to interact with a givennetwork device. All code in the OpenDaylight project is implemented in Java and is containedwithin its own Java Virtual Machine (JVM).  As such, it can be deployed on anyhardware and operating system platform that supports Java.  || Unit 3 - 64```",
            "```\fOpenDaylight - the Helium release || Unit 3 - 65```",
            "```\fOpenDaylight - the Helium releaseThe controller platform (exclusive of applications, which may also run on thecontroller) consists of a growing collection of dynamically pluggable modules,each of which performs one or more SDN-related functions and services. Five modules are considered base network service functions:Topology manager: A service for learning the network layout by subscribing to eventsof node addition and removal and their interconnection.  Applications requiring networkview can use this service. Statistics manager: Collects switch-related statistics, including flow statistics, nodeconnector, and queue occupancy. Switch manager: Holds the details of the data plane devices.  As a switch isdiscovered, its attributes (for example, what switch/router it is, software version,capabilities) are stored in a database by the switch manager. Forwarding rules manager: Installs routes and tracks next-hop information.  Works inconjunction with switch manager and topology manager to register and maintainnetwork flow state.  Applications using this need not have visibility of network devicespecifics. Host tracker: Tracks and maintains information about connected hosts.  || Unit 3 - 66```",
            "```\fREpresentational State Transfer (REST)An architectural style used to define APIsThis has become a standard way of constructing northbound APIsfor SDN controllersA REST API, or an API that is RESTful is not a protocol, language, orestablished standardIt is essentially six constraints that an API must follow to be RESTfulThe objective of these constraints is to maximize the scalability andindependence/interoperability of software interactions, and to providefor a simple means of constructing APIs || Unit 3 - 69```",
            "```\fREST ConstraintsThe six REST constraints are:• Client-server• Stateless• Cache• Uniform interface• Layered system• Code on demand || Unit 3 - 70```",
            "```\f(1) Client-ServerThis simple constraint dictates that interaction between applicationand server is in the client-server request/response styleThe principle defined for this constraint is the separation of userinterface concerns from data storage concernsThis separation allows client and server components to evolveindependently and supports the portability of server-side functionsto multiple platforms || Unit 3 - 71```",
            "```\f(2) Stateless ConstraintDictates that each request from a client to a server must contain allthe information necessary to understand the request and cannottake advantage of any stored context on the serverSimilarly, each response from the server must contain all thedesired information for that requestOne consequence is that any memory of a transaction is maintainedin a session state kept entirely on the clientAnother consequence is that if the client and server reside ondifferent machines, and therefore communicate via a protocol, thatprotocol need not be connection orientedREST typically runs over Hypertext Transfer Protocol (HTTP), whichis a stateless protocol || Unit 3 - 72```",
            "```\f(3) Cache ConstraintRequires that the data within a response to a request be implicitlyor explicitly labeled as cacheable or non-cacheableIf a response is cacheable, then a client cache is given the right toreuse that response data for later, equivalent requestsTherefore, subsequent requests for the same data can be handledlocally at the client, reducing communication overhead betweenclient and server || Unit 3 - 73```",
            "```\f(4) Uniform Interface ConstraintREST emphasizes a uniform interface between components,regardless of the specific client-server application API implementedusing RESTTo obtain a uniform interface, REST defines four interfaceconstraints:Identification of resourcesManipulation of resources through representationsSelf-descriptive messagesHypermedia as the engine of the application stateThe benefit of this constraint, for an SDN environment is thatdifferent applications can invoke the same controller service via aREST API || Unit 3 - 74```",
            "```\f(5) Layered System ConstraintA given function is organized in layers, with each layer only havingdirect interaction with the layers immediately above and belowThis is a fairly standard architecture approach for protocolarchitectures, OS design, and system services design || Unit 3 - 75```",
            "```\f(6) Code-on-Demand ConstraintREST allows client functionality to be extended by downloading andexecuting code in the form of applets or scriptsThis simplifies clients by reducing the number of features requiredto be pre-implementedAllowing features to be downloaded after deployment improvessystem extensibility || Unit 3 - 76```",
            "```\fThe APIfunctions forretrieving switchstatistics andparametersthat use the GETmessage type.  || Unit 3 - 77```",
            "```\fAPIs for Retrieving Switch and Updating Switch Statisticsand Parameters || Unit 3 - 78```"
        ]
    },
    {
        "pptName": "Unit 5",
        "slides": [
            "```\fUnit 5: Network Security Foundations5. 1Models for Network Security5. 2Information Security Principles5. 2Simple Security Protocols5. 3Authentication and TCP5. 4Secure Socket Layer (SSL/TLS)5. 5IP Security protocol (IPsec)5. 6802. 11 Wireless LAN SecurityReading: Chapters 31 and 32, Textbook – Forouzan || Unit 5 - 2```",
            "```\f5. 1 Models for Network Security || Unit 5 - 3```",
            "```\fNetwork Security Model 1TrustedpartyTrusted third partye. g. , key distributerInformation ChannelSecurity relatedtransformationMessageSecurity relatedtransformationSecureMessageBobSecureMessageMessageAliceSecretInformationSecretInformationTrudyModel 1: Information being transferred from one party to another over an insecurecommunications channel, in the presence of possible opponents.  || Unit 5 - 4```",
            "```\fNetwork Security Model 1Using this model requires us to:1.  Design a suitable algorithm for the security transformation2.  Generate the secret information (session keys) used by the algorithm3.  Develop methods to distribute and share the secret information4.  Specify a protocol enabling the principals to use the transformationand secret information for a security servicessuch as authentication, confidentiality, integrity, etc.  || Unit 5 - 5```",
            "```\fNetwork Security Model 2Trudy• Human (e. g. , hacker)• Software (e. g. , virus, worm)Access ChannelAliceGatekeeperfunction• Computer resources(e. g. , CPU, memory, I/O)• Data• Processes• SoftwareModel 2: is concerned with controlled access to information orresources on a computer system, in the presence of possibleopponents.  || Unit 5 - 6```",
            "```\fNetwork Security Model 2Using this model requires us to:Select appropriate gatekeeper functions to identify usersImplement security controls to ensure only authorised users accessdesignated information or resources || Unit 5 - 7```",
            "```\fProtocols DesignProtocols can be very subtleInnocuous change can make a significant difference in a protocolSecurity protocols are very subtleSeveral well-known security protocols have serious flawsIncluding IPSec, GSM and WEPAnd even if the protocol itself is not flawed, a particularimplementation can beIt is difficult to get protocols right…… therefore || Unit 5 - 8```",
            "```\fProtocols DesignWe need more understanding of the protocols in terms of:what does the protocol really achieve?does the protocol need more assumptions than another one?does the protocol do anything unnecessary that could be left outwithout weakening it?e. g. , does the protocol encrypt something that could be sent inclear?Let us now address the fundamental issues involved in the networksecurity protocols.  || Unit 5 - 9```",
            "```\f5. 2 Information Security Principles || Unit 5 - 10```",
            "```\fThe Importance of Information ProtectionInformation is an important asset, isn’t it?The more information you have at your command, the better you canadapt to the world around you. In business, information is often one of the most important assets acompany can possess. Information differentiates companies and provides leverage that helpsone company become more successful than another.  || Unit 5 - 11```",
            "```\fWhat is Cryptography?It’s all about controllingaccess to informationAccess to learning informationAccess to manipulateinformation || Unit 5 - 12```",
            "```\fAccess to InformationAlice, Bob and Trudy. Alice and Bob arecommunicatingAlice wants Bobto learn a message,“without Trudy learning it”AliceAlice can send outa bit string (the message) on the channel. Bob and Trudy both get itBobTrudy || Unit 5 - 13```",
            "```\fControlling Access to InformationThree algorithmsKey Generation: What Alice and Bobdo for creating the sharedsecret key (a bit string)Encryption: What Alice does withthe message and the key toobtain a “ciphertext”AlicekeyDecryption: What Bob does withthe ciphertext and the key to getthe message (the “plaintext”)out of itBobkeyTrudyAll of these are computationsWhat are the attributes of these computations? (later. . ) || Unit 5 - 14```",
            "```\fCrypto – terms and definitionsCryptology ⎯ The art and science of making and breaking “secretcodes”Cryptography ⎯ making “secret codes”Cryptanalysis ⎯ breaking “secret codes”Crypto ⎯ all of the above (and more), the precise meaning shouldbe clear from the context.  || Unit 5 - 15```",
            "```\fHow to Speak CryptoA cipher or cryptosystem is used to encrypt the plaintextThe result of encryption is ciphertextWe decrypt ciphertext to recover plaintextA key is used to configure a cryptosystemA symmetric key cryptosystem uses the same key to encrypt as todecryptA public key cryptosystem (AKA asymmetric key cryptosystem) usesa public key to encrypt and a private key to decrypt (sign) || Unit 5 - 16```",
            "```\fGeneral idea of a symmetric-key cipherAliceBob || Unit 5 - 17```",
            "```\fGeneral idea of public-key cryptosystemBobAlice || Unit 5 - 18```",
            "```\fDigital signature processBobAlice(M, S) || Unit 5 - 19```",
            "```\fFeasible ComputationIn analyzing complexity of algorithms: we rate the computationalcomplexity grows with input sizee. g.  Can do sorting in O(n log n)Only the rough rate considered. The exact time depends on the technology“Polynomial time” (O(n), O(n2), O(n3), . . . ) considered feasible || Unit 5 - 20```",
            "```\fInfeasible Computation“Super-Polynomial time” considered infeasibleFor example: O(2n), O(2√n)i. e. , as n grows, quickly becomes“infeasibly large”Can we make breakingsecurity infeasible for Trudy?What is n (that can grow)?Message size?(We need security evenif sending only one bit!) || Unit 5 - 21```",
            "```\fCryptoBasic assumptionThe system is completely known to the attackerOnly the key is secretAlso known as Kerckhoffs’ PrincipleCrypto algorithms are not secretWhy do we make this assumption?Experience has shown that secret algorithms are weak whenexposedSecret algorithms never remain secretBetter to find weaknesses before hand || Unit 5 - 22```",
            "```\fSymmetric Key Crypto NotationsP = plaintext blockC = ciphertext blockEncrypt P with key K to get ciphertext CC = E(P , K)Decrypt C with key K to get plaintext PP = D(C, K)Note thatP = D(E(P , K), K) and C = E (D(C, K), K) || Unit 5 - 23```",
            "```\fPublic Key Cypto NotationsSign message M with Alice’s private key:[M]AliceEncrypt message M with Alice’s public key:{M}AliceThen{[M]Alice}Alice = M[{M}Alice]Alice = M || Unit 5 - 24```",
            "```\f5. 2 Simple Security Protocols || Unit 5 - 25```",
            "```\fSecure Entry to NSAEmployees are given a badge that they must wear at all timeswhen they are in the secure facility. To enter the building:1. Insert badge into reader2. Enter PIN3. Correct PIN?Yes? EnterNo? Get shot by security guard || Unit 5 - 26```",
            "```\fATM Machine ProtocolWhen you withdraw money from an ATM machine, the protocol isvirtually identical to the secure entry protocol of the NSA1. Insert ATM card2. Enter PIN3. Correct PIN?Yes? Conduct your transaction(s)No? Machine eats your card || Unit 5 - 27```",
            "```\fIdentify Friend or Foe (IFF)The military has a need for many specialized security protocols.  Onesuch class of protocols is used to identify friend or foe, or IFF. Example:Consider the protocol that was used by the South African AirForce, or SAAF, when fighting in Angola. SAAF were based in Namibia, and they were fighting soldiersstationed in Angola, who were flying Soviet MiG aircraft. RussianMIGAngola || Unit 5 - 28```",
            "```\fIdentify Friend or Foe (IFF)1.  When the SAAF radar detected an aircraft approaching, a randomnumber, or challenge, N was sent to the aircraft. 2.  All SAAF aircraft knew a key K that they used to encrypt thechallenge, E(N,K), which was then sent back to the radar station. 2.  E(N,K)SAAFFighter1.  NNamibia || Unit 5 - 29```",
            "```\fMIG in the Middle3.  NSAAFfighter4.  E(N,K)Angola2.  N5.  E(N,K)RussianMiG6.  E(N,K)1.  NNamibia || Unit 5 - 30```",
            "```\fAuthentication Protocols || Unit 5 - 31```",
            "```\fAuthenticationAlice must prove her identity to BobAlice and Bob can be humans or computersMay also require Bob to prove he’s Bob (mutual authentication)May also need to establish a session keyMay have other requirements, such asUse only public keysUse only symmetric keysUse only a hash function || Unit 5 - 32```",
            "```\fAuthenticationAuthentication on a stand-alone computer is relatively simpleMain concern is an attack on authentication softwareAuthentication over a network is much more complexAttacker can passively observe messagesAttacker can replay messagesActive attacks may be possible (insert, delete, change messages) || Unit 5 - 33```",
            "```\fSimple Authentication“I’m Alice”Prove itMy password is “frank”AliceBobSimple and may be OK for standalone systemBut inefficient and insecure for networked systemSubject to a replay attack (next 2 slides)Bob must know Alice’s password || Unit 5 - 34```",
            "```\fAuthentication Attack“I’m Alice”Prove itMy password is “frank”BobAliceTrudy || Unit 5 - 35```",
            "```\fAuthentication Attack“I’m Alice”Prove itMy password is “frank”TrudyBobThis is a replay attackHow can we prevent a replay? || Unit 5 - 36```",
            "```\fSimple AuthenticationI’m Alice, My password is “frank”AliceBobMore efficient…But same problem as previous version || Unit 5 - 37```",
            "```\fBetter Authentication“I’m Alice”Prove ith(Alice’s password)AliceBobBetter since it hides Alice’s passwordFrom both Bob and attackersBut still subject to replay || Unit 5 - 38```",
            "```\fChallenge-ResponseTo prevent replay, challenge-response can be usedSuppose Bob wants to authenticate AliceChallenge sent from Bob to AliceOnly Alice can provide the correct responseChallenge chosen so that replay is not possibleHow to accomplish this?Password is something only Alice should know…For freshness, a “number used once” (or nonce) || Unit 5 - 39```",
            "```\fChallenge-Response“I’m Alice”Nonceh(Alice’s password, Nonce)AliceBobNonce is the challengeThe hash is the responseNonce prevents replay, insures freshnessPassword is something Alice knowsNote that Bob must know Alice’s password || Unit 5 - 40```",
            "```\fChallenge-Response“I’m Alice”NonceAliceSomething that could only befrom Alice (and Bob can verify)BobWhat can we use to achieve this?Hashed pwd works, crypto might be better || Unit 5 - 41```",
            "```\fChallenge-Response“I’m Alice”NonceAliceSomething that could only befrom Alice (and Bob can verify)Bob || Unit 5 - 42```",
            "```\fSymmetric Key NotationEncrypt plaintext P with key KC = E(P,K)Decrypt ciphertext C with key KP = D(C,K)Here, we are concerned with attacks on protocols, not directly onthe cryptoWe assume that crypto algorithm is secure || Unit 5 - 43```",
            "```\fSymmetric Key AuthenticationAlice and Bob share symmetric key KABKey KAB known only to Alice and BobAuthenticate by proving knowledge of shared symmetric keyHow to accomplish this?Must not reveal keyMust not allow replay attack || Unit 5 - 44```",
            "```\fChallenge-Response“I’m Alice”NonceAliceSomething that could only befrom Alice (and Bob can verify)BobLet us consider Symmetric Key || Unit 5 - 45```",
            "```\fAuthentication with Symmetric Key“I’m Alice”Alice, KABE(R,KAB)Bob, KABSecure method for Bob to authenticate AliceAlice does not authenticate BobCan we achieve mutual authentication? || Unit 5 - 46```",
            "```\fMutual Authentication?“I’m Alice”, RE(R,KAB)AliceE(R,KAB)BobWhat’s wrong with this protocol?“Alice” could be Trudy (or anybody else)! || Unit 5 - 47```",
            "```\fMutual AuthenticationSince we have a secure one-way authentication protocol…The obvious thing to do is to use the protocol twiceOnce for Bob to authenticate AliceOnce for Alice to authenticate BobThis has to work… || Unit 5 - 48```",
            "```\fMutual Authentication“I’m Alice”, RARB, E(RA,KAB)AliceE(RB,KAB)BobThis provides mutual authentication……or does it? Do you still remember the MiG-in-the-Middle attack || Unit 5 - 49```",
            "```\fMutual Authentication Attack1.  “I’m Alice”, RA2.  RB, E(RA,KAB)BobTrudy3.  “I’m Alice”, RB4.  RC, E(RB,KAB)TrudyBob || Unit 5 - 50```",
            "```\fMutual AuthenticationOur one-way authentication protocol not secure for mutualauthenticationProtocols are subtle!The “obvious” thing may not be secureAlso, if assumptions or environment changes, protocol maynot workThis is a common source of security failureFor example, Internet protocols || Unit 5 - 51```",
            "```\fSymmetric Key Mutual Authentication“I’m Alice”, RARB, E(“Bob”,RA,KAB)E(“Alice”,RB,KAB)AliceBobDo these “insignificant” changes help?Yes! || Unit 5 - 52```",
            "```\fChallenge-Response“I’m Alice”NonceAliceSomething that could only befrom Alice (and Bob can verify)BobLet us consider Public Key || Unit 5 - 53```",
            "```\fPublic Key NotationEncrypt M with Alice’s public key: {M}AliceSign M with Alice’s private key: [M]AliceThen[{M}Alice ]Alice = M{[M]Alice }Alice = MAnybody can do public key operationsOnly Alice can use her private key (sign) || Unit 5 - 54```",
            "```\fPublic Key Authentication“I’m Alice”{R}AliceAliceBobIs this secure?Trudy can get Alice to decrypt anything!Must have two key pairs || Unit 5 - 55```",
            "```\fPublic Key Authentication“I’m Alice”[R]AliceAliceBobIs this secure?Trudy can get Alice to sign anything!Must have two key pairs || Unit 5 - 56```",
            "```\fNote on Public KeysNever use the same key pair for encryption and signingOne key pair for encryption/decryptionA different key pair for signing/verifying signatures || Unit 5 - 57```",
            "```\fSession KeyIn addition to authentication, a session key is often requiredOne symmetric key is used per sessionCan we authenticate and establish a shared symmetric key?In some cases, we may also require perfect forward secrecy(PFS)Discussed later… || Unit 5 - 58```",
            "```\fAuthentication & Session KeyEncrypt only“I’m Alice”{R,K}Alice{R +1,K}BobAliceBobIs this secure?OK for key, but no mutual authentication || Unit 5 - 59```",
            "```\fAuthentication & Session KeySign only“I’m Alice” , R[R,K]BobAlice[R +1,K]AliceBobIs this secure?Mutual authentication but key is not secret! || Unit 5 - 60```",
            "```\fAuthentication & Session KeySign and Encrypt“I’m Alice” , R{[R,K]Bob}Alice{[R +1,K]Alice}BobAliceBobIs this secure?Seems to be OKMutual authentication and session key! || Unit 5 - 61```",
            "```\fAuthentication & Session KeyEncrypt and Sign“I’m Alice” , R[{R,K}Alice]Bob[{R +1,K}Bob]AliceAliceBobIs this secure?Seems to be OKAnyone can see {R,K}Alice and {R +1,K}Bob || Unit 5 - 62```",
            "```\fPerfect Forward SecrecyThe concern…Alice encrypts message with shared key KAB and sendsciphertext to BobTrudy records ciphertext and later attacks Alice’s (or Bob’s)computer to find KABThen Trudy decrypts recorded messagesPerfect forward secrecy (PFS): Trudy cannot later decrypt recordedciphertextEven if Trudy gets key KAB or other secret(s)Is PFS possible? || Unit 5 - 63```",
            "```\fPerfect Forward SecrecySuppose Alice and Bob share key KABFor perfect forward secrecy, Alice and Bob cannot use KAB toencryptInstead they must use a session key KS and forget it after it’s usedProblem: How can Alice and Bob agree on session key KS andensure PFS? || Unit 5 - 64```",
            "```\fDiffie-HellmanInvented by Whitfield Diffie and Martin HellmanA “key exchange” algorithmUsed to establish a shared symmetric keyNot for encrypting or signingSecurity rests on difficulty of discrete logarithm problem:given g, p, and (gk mod p)find kThe discrete log problem is very difficult to solve || Unit 5 - 65```",
            "```\fDiffie-HellmanLet p be prime, let g be a generatorFor any x  {1,2,…,p-1} there is n such thatx = gn mod pThe process: (g and p are public)Alice selects secret value aBob selects secret value bAlice sends ga mod p to BobBob sends gb mod p to AliceBoth compute shared secret gab mod pShared secret can be used as symmetric key || Unit 5 - 66```",
            "```\fDiffie-Hellman - key exchangePublic: g and pSecret: Alice’s exponent a, Bob’s exponent bga mod pgb mod pAlice, aBob, b(ga)b = gab mod pAlice computes (gb) a = gba = gab mod pBoth could use K = gab mod p as symmetric keyBob computes || Unit 5 - 67```",
            "```\fDiffie-HellmanSuppose that Bob and Alice use gab mod p as a symmetric keyTrudy can see ga mod p and gb mod pNote ga gb mod p = ga+b mod p  gab mod pIf Trudy can find a or b, the system is brokenIf Trudy can solve discrete log problem, then she can find a or b || Unit 5 - 68```",
            "```\fDiffie-Hellman - Example 1If Alice and Bob agree on the values:p = 113 g = 23then Alice selects the secret value 4 and sends Bob the value234 mod 113 = 53While Bob selects the secret value 11 and sends Alice the value2311 mod 113 = 27They both calculate the common key:Bob5311 mod 113 = 2Alice274 mod 113 = 2 || Unit 5 - 69```",
            "```\fExample 2If Alice and Bob agree on the values:p = 76825670157115949022871g = 129633then Alice selects the secret value 1567and Bob selects his secret value 3001So Alice sends 3748860625118221776574 to Bob andBob sends 34126923917580261813405 to Alice. They both calculate the common key:32347879715377627749156 || Unit 5 - 70```",
            "```\fDiffie-Hellman - MiM attackSubject to man-in-the-middle (MiM) attackAlice, aga mod pgt mod pgt mod pgb mod pTrudy, tBob, bTrudy shares secret gat mod p with AliceTrudy shares secret gbt mod p with BobAlice and Bob don’t know Trudy exists! || Unit 5 - 71```",
            "```\fDiffie-HellmanHow to prevent MiM attack?Encrypt DH exchange with symmetric keyEncrypt DH exchange with public keySign DH values with private keyYou MUST be aware of MiM attack on Diffie-Hellman || Unit 5 - 72```",
            "```\fPerfect Forward SecrecyCan use Diffie-Hellman for PFSRecall Diffie-Hellman: public g and pga mod pgb mod pAlice, aBob, bBut Diffie-Hellman is subject to MiMHow to get PFS and prevent MiM? || Unit 5 - 73```",
            "```\fPerfect Forward SecrecyE(ga mod p, KAB)E(gb mod p, KAB)Alice, aBob, bSession key KS = gab mod pAlice forgets a, Bob forgets bEphemeral Diffie-HellmanNot even Alice and Bob can later recover KSOther ways to do PFS? || Unit 5 - 74```",
            "```\fMutual Authentication, Session Keyand PFS“I’m Alice”, RARB, [{RA, gb mod p}Alice]Bob[{RB, ga mod p}Bob]AliceAliceBobSession key is K = gab mod pAlice forgets a and Bob forgets bIf Trudy later gets Bob’s and Alice’s secrets, she cannotrecover session key K || Unit 5 - 75```",
            "```\fTimestampsA timestamp T is the current timeTimestamps used in many security protocols (Kerberos, forexample)Timestamps reduce number of messagesLike a nonce that both sides know in advanceClocks never exactly the same, so must allow for clock skew ⎯ riskof replayHow much clock skew is enough? || Unit 5 - 76```",
            "```\fPublic Key Authentication with Timestamp TSign and Encrypt“I’m Alice”, {[T,K]Alice}Bob{[T +1,K]Bob}AliceAliceBobIs this secure?Seems to be OK || Unit 5 - 77```",
            "```\fPublic Key Authentication with Timestamp TEncrypt and Sign“I’m Alice”, [{T,K}Bob]Alice[{T +1,K}Alice]BobAliceBobIs this secure?Trudy can use Alice’s public key to find{T,K}Bob so what… || Unit 5 - 78```",
            "```\fPublic Key Authentication with Timestamp TEncrypt and Sign“I’m Trudy”, [{T,K}Bob]Trudy[{T +1,K}Trudy]BobTrudyBobTrudy obtains Alice-Bob session key KNote: Trudy must act within clock skew || Unit 5 - 79```",
            "```\fPublic Key AuthenticationSign and encrypt with nonce…SecureEncrypt and sign with nonce…SecureSign and encrypt with timestamp…SecureEncrypt and sign with timestamp…InsecureProtocols can be subtle! || Unit 5 - 80```",
            "```\fPublic Key Authentication with Timestamp T(Secure) Encrypt and Sign“I’m Alice”, [{T,K}Bob]Alice[{T +1}Alice]BobAliceBobIs this “encrypt and sign” secure?Yes, seems to beDoes “sign and encrypt” also work here? || Unit 5 - 81```",
            "```\fMutual Authentication, with Public KeySign and encrypt with nonce…SecureEncrypt and sign with nonce…SecureSign and encrypt with timestamp…SecureEncrypt and sign with timestamp…Secure || Unit 5 - 82```",
            "```\f5. 3 Authentication and TCP || Unit 5 - 83```",
            "```\fTCP-based AuthenticationTCP not intended for use as an authentication protocolBut IP address in TCP connection often used for authenticationOne mode of IPSec uses IP address for authenticationThis can cause problems || Unit 5 - 84```",
            "```\fTCP 3-way HandshakeSYN, SEQ aSYN-ACK a+1, SEQ bACK b+1, dataAliceBobRecall the TCP three way handshakeInitial SEQ numbers, SEQ a and SEQ bSupposed to be randomIf not… || Unit 5 - 85```",
            "```\fTCP Authentication AttackBobTrudy5. 5. 5. 5. Alice || Unit 5 - 86```",
            "```\fTCP Authentication AttackTrudy cannot see what Bob sends, but she can send packets to Bob,while posing as AliceTrudy must prevent Alice from receiving Bob’s packets (or elseconnection will terminate)If password (or other authentication) required, this attack failsIf TCP connection is relied on for authentication, then attack cansucceedBad idea to rely on TCP for authentication || Unit 5 - 87```",
            "```\fBest Authentication Protocol?What is best, depends on many factors…The sensitivity of the applicationThe delay that is tolerableThe cost (computation) that is tolerableWhat crypto is supportedPublic key, symmetric key, hash functionsIs mutual authentication required?Is a session key required?Is PFS a concern?, etc.  || Unit 5 - 88```",
            "```\f5. 4 Secure Socket Layer (SSL/TLS) || Unit 5 - 89```",
            "```\fSocket layer“Socket layer” livesbetween application andtransport layersSSL usually lies betweenHTTP and TCPSocket“layer”applicationUsertransportOSnetworklinkNICphysical || Unit 5 - 90```",
            "```\fWhat is SSL?SSL (and IEEE standard known as TLS) is the protocol used for mostsecure transactions over the InternetFor example, if you want to buy a book at amazon. com…You want to be sure you are dealing with Amazon(authentication)Your credit card information must be protected in transit(confidentiality and/or integrity)As long as you have money, Amazon doesn’t care who you are(authentication need not be mutual) || Unit 5 - 91```",
            "```\fSimple SSL-like ProtocolI’d like to talk to you securelyHere’s my certificate{KAB}BobAliceprotected HTTPBobIs Alice sure she’s talking to Bob?Is Bob sure he’s talking to Alice? || Unit 5 - 92```",
            "```\fSimplified SSL ProtocolCan we talk?, cipher list, RAcertificate, cipher, RB{S}Bob, E(h(msgs,CLNT,K),K)Aliceh(msgs,SRVR,K)Data protected with key KBobS is pre-master secretK = h(S,RA,RB)msgs = all previous messagesCLNT and SRVR are string constants || Unit 5 - 93```",
            "```\fSimplified SSL Protocol1. Alice informs Bob that she would like to establish an SSL connection, andshe passes a list of ciphers that she supports, along with a nonce RA. 2. Bob responds with his certificate, he selects one of the ciphers from theciphers list that Alice sent in message one, and he sends a nonce RB. 3. Alice sends the S that she generated, along with a hash that is encryptedwith the key K.  In this hash, “msgs” includes all previous messages andCLNT is a literal string.  The hash is used to verify that the previousmessages have been received correctly4. Bob responds with a similar hash.  Alice can thereby verify that Bobreceived the messages correctly, and, more importantly, she canauthenticate Bob, since only Bob could have decrypted S, which isrequired to generate the key K.  || Unit 5 - 94```",
            "```\fSSL Keys6 “keys” derived from K = hash(S,RA,RB)2 encryption keys: 1 for sending and 1 for receiving data2 integrity keys: 1 for sending and 1 for receiving data2 IVs: 1 for sending and 1 for receiving dataQ: Why different keys in each direction?A: may help to prevent certain types of replay attacks.  || Unit 5 - 95```",
            "```\fSSL AuthenticationAlice authenticates Bob, not vice-versaHow does client authenticate server?Why does server not authenticate client?Mutual authentication is possible: Bob sends certificate request inmessage 2This requires client to have certificateIf server wants to authenticate client, server could insteadrequire (encrypted) password || Unit 5 - 96```",
            "```\fSimplified SSL ProtocolCan we talk?, cipher list, RAcertificate, cipher, RB{S}Bob, E(h(msgs,CLNT,K),K)h(msgs,SRVR,K)AliceclientData protected with key KBobserver || Unit 5 - 97```",
            "```\fSSL MiM AttackAliceRAcertificateT, RB{S1}Trudy,E(X1,K1)h(Y1,K1)E(data,K1)TrudyRAcertificateB, RB{S2}Bob,E(X2,K2)h(Y2,K2)E(data,K2)BobQ: What prevents this MiM attack?A: Bob’s certificate must be signed by a certificate authority(such as Verisign)What does Web browser do if signature not valid?What does user do if signature is not valid? || Unit 5 - 98```",
            "```\fSSL Sessions vs ConnectionsSSL session is established as shown on previous slidesSSL designed for use with HTTP 1. 0HTTP 1. 0 usually opens multiple simultaneous (parallel) connectionsSSL session establishment is costlyDue to public key operationsSSL has an efficient protocol for opening new connections given anexisting session || Unit 5 - 99```",
            "```\fSSL Connectionsession-ID, cipher list, RAsession-ID, cipher, RB,h(msgs,SRVR,K)h(msgs,CLNT,K)AliceProtected dataBobAssuming SSL session existsSo S is already known to Alice and BobBoth sides must remember session-IDAgain, K = h(S,RA,RB)No public key operations! (relies on known S) || Unit 5 - 100```",
            "```\fSSL vs IPSecIPSec ⎯ will be given in next slidesLives at the network layer (part of the OS)Has encryption, integrity, authentication, etc. Is overly complex (including serious flaws)SSL (and IEEE standard known as TLS)Lives at socket layer (part of user space)Has encryption, integrity, authentication, etc. Has a simpler specification || Unit 5 - 101```",
            "```\fSSL vs IPSecIPSec implementationRequires changes to OS, but no changes to applicationsSSL implementationRequires changes to applications, but no changes to OSSSL built into Web application early on (Netscape)IPSec used in VPN “virtual private network” applications (secure tunnel)Reluctance to put more research and build more applications for SSLReluctance to use IPSec due to complexity and interoperability issuesResult? Internet less secure than it should be! || Unit 5 - 102```",
            "```\f5. 5 IP Security protocol (IPsec) || Unit 5 - 103```",
            "```\fIPSec and SSLIPSec lives at thenetwork layerIPSec is transparentto applicationsSSLIPSecapplicationUsertransportOSnetworklinkNICphysical || Unit 5 - 104```",
            "```\fIPSec and ComplexityIPSec is a complex protocolOver-engineeredLots of generally useless extra featuresFlawedSome serious security flawsInteroperability is serious challengeDefeats the purpose of having a standard!ComplexDid I mention, it’s complex? || Unit 5 - 105```",
            "```\fIKE and ESP/AHTwo parts to IPSecIKE: Internet Key ExchangeMutual authenticationEstablish shared symmetric keyTwo “phases” ⎯ like SSL session/connectionESP/AHESP: Encapsulating Security Payload ⎯ for encryption and/orintegrity of IP packetsAH: Authentication Header ⎯ integrity only || Unit 5 - 106```",
            "```\fIKE || Unit 5 - 107```",
            "```\fIKEIKE has 2 phasesPhase 1 ⎯ IKE security association (SA)Phase 2 ⎯ IPSec security associationPhase 1 is comparable to SSL sessionPhase 2 is comparable to SSL connectionNot an obvious need for two phases in IKEIf multiple Phase 2’s do not occur, then it is more expensive to havetwo phases! || Unit 5 - 108```",
            "```\fIKE Phase 1Four different “key” optionsPublic key encryption (original version)Public key encryption (improved version)Public key signatureSymmetric keyFor each of these, two different “modes”Main modeAggressive modeThere are 8 versions of IKE Phase 1!Evidence that IPSec is over-engineered? || Unit 5 - 109```",
            "```\fIKE Phase 1We’ll discuss 6 of 8 phase 1 variantsPublic key signatures (main and aggressive modes)Symmetric key (main and aggressive modes)Public key encryption (main and aggressive)Why public key encryption and public key signatures?Always know your own private keyMay not (initially) know other side’s public key || Unit 5 - 110```",
            "```\fIKE Phase 1Uses ephemeral Diffie-Hellman to establish session keyAchieves perfect forward secrecy (PFS)Let a be Alice’s Diffie-Hellman exponentLet b be Bob’s Diffie-Hellman exponentLet g be generator and p primeRecall p and g are public || Unit 5 - 111```",
            "```\fIKE Phase 1: Digital Signature (Main Mode)IC, CPIC,RC, CSIC,RC, ga mod p, RAIC,RC, gb mod p, RBAliceIC,RC, E(“Alice”, proofA, K)IC,RC, E(“Bob”, proofB, K)BobCP = crypto proposed, CS = crypto selectedIC = initiator “cookie”, RC = responder “cookie”K = h(IC,RC,gab mod p,RA,RB)SKEYID = h(RA, RB, gab mod p)proofA = [h(SKEYID,ga mod p, gb mod p,IC,RC,CP,“Alice”)]Alice || Unit 5 - 112```",
            "```\fIKE Phase 1: Digital Signature (MainMode)In the first message Alice provides information on the ciphers that shesupports along with a “cookie” . In message two, Bob selects from Alice’s crypto proposal and sends thecookies. The third message includes a nonce and Alice’s Diffie-Hellman value. Bob responds similarly in message four, providing a nonce and his DiffieHellman value. In the final two messages, Alice and Bob authenticate each other usingdigital signatures. A passive attacker cannot recognize Alice or Bob’s identity, so this protocolprovides anonymity. In the aggressive mode version of digital signatures, there is no attempt tohide the identities of Alice or Bob.  || Unit 5 - 113```",
            "```\fIKE Phase 1: Public Key Signature (Aggressive Mode)IC, “Alice”, ga mod p, RA, CPIC,RC, “Bob”, RB,gb mod p, CS, proofBAliceIC,RC, proofABobMain difference from main modeNot trying to protect identitiesCannot negotiate g or p || Unit 5 - 114```",
            "```\fMain vs Aggressive ModesFor public key signature authenticationPassive attacker knows identities of Alice and Bob inaggressive modeActive attacker can determine Alice’s and Bob’s identity inmain mode || Unit 5 - 115```",
            "```\fIC, CPIC,RC, CSIC,RC, ga mod p, RAIC,RC, gb mod p, RBAliceIC,RC, E(“Alice”, proofA, K)IC,RC, E(“Bob”, proofB, K)BobCP = crypto proposed, CS = crypto selectedIC = initiator “cookie”, RC = responder “cookie”K = h(IC,RC,gab mod p,RA,RB)SKEYID = h(RA, RB, gab mod p)proofA = [h(SKEYID,ga,gb,IC,RC,CP,“Alice”)]Alice || Unit 5 - 116```",
            "```\fIKE Phase 1: Symmetric Key (Main Mode)IC, CPIC,RC, CSIC,RC, ga mod p, RAAliceIC,RC, gb mod p, RBIC,RC, E(“Alice”, proofA, K)IC,RC, E(“Bob”, proofB, K)BobSame as signature mode exceptKAB = symmetric key shared in advanceK = h(IC,RC,gab mod p,RA,RB,KAB)SKEYID = h(K, gab mod p)proofA = h(SKEYID ,ga mod p ,gb mod p,IC,RC,CP,“Alice”) || Unit 5 - 117```",
            "```\fProblems with Symmetric Key (Main Mode)Here is the Catch!Alice sends her ID in message 5Alice’s ID encrypted with KTo find K Bob must know KABTo get KAB Bob must know he’s talking to Alice!Result: Alice’s ID must be IP address!Useless mode for the “road warrior”Why go to all of the trouble of trying to hide identities in 6message protocol? || Unit 5 - 118```",
            "```\fIKE Phase 1: Symmetric Key (Aggressive Mode)IC, “Alice”, ga mod p, RA, CPIC,RC, “Bob”, RB,gb mod p, CS, proofBAliceIC,RC, proofABobSame format as digital signature aggressive modeNot trying to hide identities…As a result, does not have problems of main modeBut does not (pretend to) hide identities || Unit 5 - 119```",
            "```\fIKE Phase 1: Public Key Encryption (Main Mode)IC, CPIC,RC, CSIC,RC, ga mod p, {RA}Bob, {“Alice”}BobIC,RC, gb mod p, {RB}Alice, {“Bob”}AliceAliceIC,RC, E(proofA, K)IC,RC, E(proofB, K)BobCP = crypto proposed, CS = crypto selectedIC = initiator “cookie”, RC = responder “cookie”K = h(IC,RC,gab mod p,RA,RB)SKEYID = h(RA, RB, gab mod p)proofA = h(SKEYID,ga,gb,IC,RC,CP,“Alice”) || Unit 5 - 120```",
            "```\fIKE Phase 1: Public Key Encryption(Aggressive Mode)IC, CP, ga mod p,{“Alice”}Bob, {RA}BobIC,RC, CS, gb mod p,{“Bob”}Alice, {RB}Alice, proofBAliceIC,RC, proofABobK, proofA, proofB computed as in main modeNote that identities are hiddenThe only aggressive mode to hide identitiesThen why have main mode? || Unit 5 - 121```",
            "```\fPublic Key Encryption Issue?Public key encryption, aggressive modeSuppose Trudy generatesExponents a and bNonces RA and RBTrudy can compute “valid” keys and proofs: gab mod p, K,SKEYID, proofA and proofBAlso true of main mode || Unit 5 - 122```",
            "```\fPublic Key Encryption Issue?IC, CP, ga mod p,{“Alice”}Bob, {RA}BobIC,RC, CS, gb mod p,{“Bob”}Alice, {RB}Alice, proofBTrudyas AliceIC,RC, proofATrudyas BobTrudy can create exchange that appears to be between Aliceand BobAppears valid to any observer, including Alice and Bob! || Unit 5 - 123```",
            "```\fPlausible DeniabilityTrudy can create “conversation” that appears to be betweenAlice and BobAppears valid, even to Alice and Bob!A security failure?In this mode of IPSec, it is a featurePlausible deniability: Alice and Bob can deny that anyconversation took place!In some cases it might be a security failureIf Alice makes a purchase from Bob, she could laterrepudiate it (unless she had signed) || Unit 5 - 124```",
            "```\fIKE Phase 1 CookiesCookies (or “anti-clogging tokens”)provide a weak form of source address identification for both partiessupposed to make denial of service more difficultNo relation to Web cookiesTo reduce DoS, Bob wants to remain stateless as long as possibleBut Bob must remember CP from message 1 (required for proof ofidentity in message 6)Bob must keep state from 1st message on!These cookies offer little DoS protection! || Unit 5 - 125```",
            "```\fIKE Phase 1 SummaryResult of IKE phase 1 isMutual authenticationShared symmetric keyIKE Security Association (SA)But phase 1 is expensive (in public key and/or main mode cases)Developers of IKE thought it would be used for lots of things ⎯ notjust IPSecPartly explains over-engineering… || Unit 5 - 126```",
            "```\fIKE Phase 2Phase 1 establishes IKE SAPhase 2 establishes IPSec SAComparison to SSLSSL session is comparable to IKE Phase 1SSL connections are like IKE Phase 2IKE could be used for lots of thingsBut in practice, it’s not! || Unit 5 - 127```",
            "```\fIKE Phase 2IC,RC,CP,E(hash1,SA,RA,K)IC,RC,CS,E(hash2,SA,RB,K)AliceIC,RC,E(hash3,K)BobKey K, IC, RC and SA known from Phase 1Proposal CP includes ESP and/or AHHashes 1,2,3 depend on SKEYID, SA, RA and RBKeys derived from h(SKEYID,RA,RB,junk), junk is publicRecall SKEYID depends on phase 1 key methodOptional PFS (ephemeral Diffie-Hellman exchange) || Unit 5 - 128```",
            "```\fIPSecAfter IKE Phase 1, we have an IKE SAAfter IKE Phase 2, we have an IPSec SABoth sides have a shared symmetric keyNow what?We want to protect IP datagramsBut what is an IP datagram?From the perspective of IPSec… || Unit 5 - 129```",
            "```\fIP ReviewIP datagram is of the formIP headerdataWhere IP header is || Unit 5 - 130```",
            "```\fIP and TCPConsider HTTP traffic (over TCP)IP encapsulates TCPTCP encapsulates HTTPIP headerdataIP headerTCP hdrHTTP hdrapp dataIP data includes TCP header, etc.  || Unit 5 - 131```",
            "```\fIPSec Transport ModeIPSec Transport ModeIP header dataIP header ESP/AHdataTransport mode designed for host-to-hostTransport mode is efficientAdds minimal amount of extra headerThe original header remains intactPassive attacker can see who is talking || Unit 5 - 132```",
            "```\fIPSec: Host-to-HostIPSec transport modeNote that there may be firewalls in between ⎯ is that a problem? || Unit 5 - 133```",
            "```\fIPSec Tunnel ModeIPSec Tunnel ModeIP header datanew IP hdrESP/AHIP header dataTunnel mode for firewall to firewall trafficOriginal IP packet encapsulated in IPSecOriginal IP header not visible to attackerNew header from firewall to firewallAttacker does not know which hosts are talking || Unit 5 - 134```",
            "```\fIPSec: Firewall-to-FirewallIPSec tunnel modeLocal networks unprotectedSo, is there any advantage here? || Unit 5 - 135```",
            "```\fComparison of IPSec ModesTransport ModeHost-to-hostTransport ModeIP header dataIP header ESP/AHTunnel ModeFirewall-to-firewalldataTunnel ModeIP header datanew IP hdrESP/AHTransport mode notnecessaryTransport mode moreefficientIP header data || Unit 5 - 136```",
            "```\fTransport Mode and Tunnel ModeIndependent of whether ESP or AH is used, IPSec can use eithertransport mode ortunnel mode. In transport mode the new ESP/AH header is sandwiched betweenthe IP header and the data. In tunnel mode the entire IP packet is encapsulated in a new IPpacket.  || Unit 5 - 137```",
            "```\fAH vs ESPAH: Authentication HeaderIntegrity only (no confidentiality)Integrity-protect everything beyond IP header and somefields of header (why not all fields?)ESP: Encapsulating Security PayloadIntegrity and confidentiality both requiredProtects everything beyond IP headerIntegrity only by using NULL encryption || Unit 5 - 138```",
            "```\fESP’s NULL EncryptionAccording to RFC 2410NULL encryption “is a block cipher the origins of which appear tobe lost in antiquity”“Despite rumors”, there is no evidence that NSA “suppressedpublication of this algorithm”Evidence suggests it was developed in Roman times asexportable version of Caesar’s cipherCan make use of keys of varying lengthNo IV is requiredNull(P,K) = P for any P and any key KSecurity people have a strange sense of humor! || Unit 5 - 139```",
            "```\fWhy Does AH Exist? (1)Cannot encrypt IP headerRouters must look at the IP headerIP addresses, TTL, etc. IP header exists to route packets!AH protects immutable fields in IP headerCannot integrity protect all header fieldsTTL, for example, must changeESP does not protect IP header at all || Unit 5 - 140```",
            "```\fWhy Does AH Exist? (2)ESP encrypts everything beyond the IP header (if non-nullencryption)If ESP encrypted, firewall cannot look at TCP header (e. g. , portnumbers)Why not use ESP with null encryption?Firewall sees ESP header, but does not know whether nullencryption is used || Unit 5 - 141```",
            "```\fWhy Does AH Exist? (3)The real reason why AH existsAt one IETF meeting “someone from Microsoft gave an impassionedspeech about how AH was useless…”“…everyone in the room looked around and said `Hmm.  He’s right, andwe hate AH also, but if it annoys Microsoft let’s leave it in since we hateMicrosoft more than we hate AH. ” || Unit 5 - 142```",
            "```\fIPSec SecurityWhat kind of protection?Confidentiality?Integrity?Both?What to protect?Data?Header?Both?ESP/AH do some combinations of these || Unit 5 - 143```",
            "```\f5. 6 802. 11 Wireless LAN Security || Unit 5 - 144```",
            "```\f802. 11 Wireless LAN SecurityWireless traffic can be monitored by any radio in range, and need not bephysically connected. The original 802. 11 specification had security featuresWired Equivalent Privacy (WEP) algorithmbut found this contained major weaknesses802. 11i task group developed capabilities to address WLAN security issuesWi-Fi Alliance Wi-Fi Protected Access (WPA)Final 802. 11i Robust Security Network (RSN) || Unit 5 - 145```",
            "```\f802. 11i RSN - GoalsReplace WEP by protocol that properly uses encryptionAdd data authenticity and integrityAdd proper authenticationManufacture “fresh” keys for every sessionTie keys to the authentication || Unit 5 - 146```",
            "```\f802. 11i RSN Services and ProtocolsMAC-level data areencrypted, along with amessage integrity codethat ensures that the datahave not been alteredServicesRobust Security Network (RSN)AccessControlAuthentication andKey generationProtocolEnforces the use of theauthentication function,routes the messagesproperly, and facilitates keyexchangeIEEE 802. 1xPort-basedaccesscontrolExtensibleAuthenticationProtocol (EAP)A protocol is used to define anexchange between a user and anAS that provides mutualauthentication and generatestemporary keysConfidentiality andIntegrityTKIPCCMPTKIP = Temporal Key Integrity ProtocolCCMP = Counter Mode with CBCMAC Protocol || Unit 5 - 147```",
            "```\f802. 11i RSN Cryptographic AlgorithmsAlgorithmServicesRobust Security Network (RSN)ConfidentialityTKIP(RC4)CCMP(AES)Integrity and AuthenticationHMACSHA-1HMACMD5TKIP(MichaelMIC)CCM(AES CBCMAC)KeyGenerationHMACSHA-1 || Unit 5 - 148```",
            "```\f802. 11i Phases of Operation1. 2. 3. 4. 5. IEEE 802. 11i RSN can be broken down into five distinct phases of:Discovery: an STA and an AP are involved in this phase. An STA and an AP recognize each otherAgree on set of security capabilitiesEstablish an association for future communication using these securitycapabilitiesAuthentication: an STA, an AP and the AS are involved in this phase. An STA and AS mutually authenticate each otherKey Management: an STA, an AP and the AS are involved in this phase as well. Cryptographic keys will be generated by the AS to be moved to AP and thenpushed to the STA. Protected data transfer: Frames are exchanged between the STA and the other STA(end station) through the AP.  security is not provided end-to-end. Connection termination: The AP and STA exchange frames to turn down the secureconnection.  || Unit 5 - 149```",
            "```\f802. 11i Phases of OperationSecuritycapabilitiesdiscoverySTA <-> ASmutualauthentication802. 1X keymanagementRADIUS-basedkey distributionSTA <-> APencryptedchannel.  Notend-to-endprotection || Unit 5 - 150```",
            "```\fDigging deeper - Discovery phaseAn STA and an AP recognize each other and agree on a set of security capabilities tobe used after the association. These security capabilities include:Confidentiality and integrity protocols for protecting unicast traffic (only betweenSTA and AP.  Only AP specifies the protecting multicast traffic),Authentication method,Cryptography key management approach. The specification of a protocol, along with the chosen key length (if variable) is knownas a cipher suite. The options for the confidentiality and integrity cipher suite are:WEP, (for backward compatibility), TKIP, CCMP, vendor-specific methods. The options for the authentication and key management (AKM) suite are:IEEE 802. 1X, pre-shared key PSK, vendor-specific methods).  || Unit 5 - 151```",
            "```\fDigging deeper - Discovery phaseProbe RequestProbe Response + RSN IE (AP supports CCMPMcast, CCMP Ucast, 802. 1X Auth)STA802. 11 Open System AuthAP802. 11 Open Auth (success)Association Req + RSN IE (STA requestsCCMP Mcast, CCMP Ucast, 802. 1X Auth)Association Response (success)Three MPDU (frame) exchanges:1.  Network and security capability discovery, through passive or active scanning.  APadvertises its RSN Information Element (RSN IE)2.  Open system authentication to maintain a backward computability with legacy 802. 11devices (STA or AP) to perform simple exchange identities. 3.  Association, to agree and confirm the chosen cipher suites between STA and AP || Unit 5 - 152```",
            "```\fDiscovery phase – SummaryAt the end of discoverySTA knowsThe alleged SSID (AP) of the networkThe alleged authentication and cipher suites of the networkThe AP knows which of its authentication and cipher suites the STAallegedly choseA STA and an AP have established an 802. 11 channelThe associated STA and AP are ready to authenticate || Unit 5 - 153```",
            "```\fDigging deeper - Authentication phaseGoalsEstablish a mutually authenticated session between STA and ASEstablish a session key shared by AS and STASession  key is freshMutually authenticated  bound only to AS and STATied back to authorization decisionDefend against eavesdropping, man-in-the-middle attacks, forgeries,replay, dictionary attacks against either party. Identity protection not a goalCan’t hide the MAC address || Unit 5 - 154```",
            "```\fDigging deeper - Authentication phaseIEEE 802. 11i makes use of another standard that was designed to provide accesscontrol functions for LANs. The standard is IEEE 802. 1X, Port-Based Network Access Control. Defined in IEEE STD 802. 1X-2001Runs over all 802 LANsAllow/deny port filtering rulesMany parts of how 802. 1x works are within other standards such asEAP (Extensible Authentication Protocol) , more later,and RADIUS (Remote Authentication Dial-In User Service) . The 802. 1x standard is just a mechanism that denies all traffic except EAP packetsfrom accessing the networkRADIUS protocol is used to create an encrypted tunnel between the AP and the AS(aka RADIUS server), more later. IEEE 802. 1X uses the terms supplicant, authenticator, that are correspond to thewireless station and the AP.  || Unit 5 - 155```",
            "```\fDigging deeper - Authentication phaseSTAAPSTA 802. 1X blocks port fordata trafficASAP 802. 1X blocks port for datatrafficthe AP controlledport is still blockedto data traffic802. 1X/EAP-Request Identity802. 1X/EAP-Response Identity(EAP type specific)RADIUS Access Request/IdentityEAP type specific mutual authenticationDerive Pairwise Master Key (PMK)Derive Pairwise Master Key (PMK)RADIUS Accept (with PMK)802. 1X/EAP-SUCCESS802. 1XRADIUS || Unit 5 - 156```",
            "```\fDigging deeper – (EAP)Extensive Authentication Protocol (EAP) is an authentication framework (defined inRFC 3748 )EAP provides a transport for keying material and parameters generated by EAPmethods. EAP relies on “concrete” methods plugged into it for authenticationE. g. , EAP-TLS, EAP-TTLS, EAP-MD5, etc. EAP only defines message formats.  Each protocol that uses EAP defines a wayto encapsulate EAP messages within that protocol's messages. E. g. , the encapsulation of EAP over IEEE 802 is defined in IEEE 802. 1X andknown as \"EAP over LANs\" or EAPOLRADIUS protocols can also encapsulate EAP messages.  They are often used byNetwork Access Server (NAS) devices to forward EAP packets between AccessPoint and these Authentication Servers. EAP frame is made up of five main fields: code, identifier, length, type, and data. (see next slide) || Unit 5 - 157```",
            "```\fDigging deeper – (EAP)1 → EAP Request2 → EAP Response3 → Success Indicator4 → Failure IndicatorTo match responseswith requests.  Mustbe changed on eachRequest packet. Identifies the structureof an EAP packet. E. g. , 13 → EAP-TLSEAP messageCodeIdentifier1 Byte1 ByteThe length of theEAP packetLength2 BytesType1 ByteDataVariable LengthHere, a user would providethe authentication portion || Unit 5 - 158```",
            "```\fDigging deeper – RADIUSThe RADIUS protocol specifications are currently defined in RFC 2865 andRFC 2866. RADIUS is a client/server protocol that runs in the application layer,using UDP as transport. The protocol works by creating an encrypted tunnel between the networkdevice and the RADIUS server. This tunnel is used for sending all the Authentication AuthorizationAccounting (AAA) information. To start this encrypted tunnel, a phrase or password called the sharedsecret between the AP and AS is needed. Once the shared secret is correctly set up, secure communication cantake place.  || Unit 5 - 159```",
            "```\fDigging deeper – RADIUS1 → Access-Request. 2 → Access-Accept3 → Access-Reject4 → Access-ChallengeRADIUS packet formatsCodeIdentifier1 Byte1 ByteLength2 BytesAuthenticator16 ByteRADIUS has only four types of packets for authentication and there are other packettypes for accounting.  However, we only focus on the authentication packets. 1.  Access-Request.  This packet allows the RADIUS sequence to take place. 2.  Access-Accept.  This packet informs the RADIUS client that the authenticationprovided to it was correct. 3.  Access-Reject.  This packet informs the RADIUS client that the authenticationprovided to it was incorrect. 4.  Access-Challenge.  This packet is used to challenge a RADIUS client for itsauthentication credentials.  || Unit 5 - 160```",
            "```\fDigging deeper – EAP-TLSEAP-TLS is not part of 802. 11i; neither is any other specific authenticationmethodBut EAP-TLS is the de facto 802. 11i authentication methodCan meet all 802. 11i requirementsOther widely deployed methods do notEAP-TLS = TLS Handshake over EAPEAP-TLS defined by RFC 2716TLS defined by RFC 2246Always requires provisioning AS certificate on the STAMutual authentication requires provisioning STA certificates || Unit 5 - 161```",
            "```\fDigging deeper – EAP-TLSRemember, EAP frame is made up of five main fields: code, identifier, length, type,and data. Always 13EAP messageCodeIdentifier1 Byte1 ByteLengthType2 BytesFlags1 ByteTLS Message Length1 ByteL = Length includedM = More fragmentsS = EAP-TLS start*R = ReservedM S4 BytesR RDataVariable LengthTLS Data .  .  . Variable LengthR R* The start bit is exist only when Code =1 (EAP request).  For all other codes it is R || Unit 5 - 162```",
            "```\fExample –EAP-TLS (1)STAAPAP-RADIUS KeyAS802. 1X/EAP-Request Identity802. 1X/EAP-Response IdentityRADIUS_Access_Request/EAPResponse Identity802. 1X/EAP-requestEAP type = TLSTLS start bit setRADIUS_access_challengeEAP type = TLS802. 1X/EAP-responseEAP type = TLSTLS client_helloRADIUS_Access_Request/EAPResponse EAP type = TLSTLS client_hello802. 1X/EAP-responseEAP type = TLSTLS server_hello, TLScertificate, TLS server keyexchange, TLS certificaterequest, TLS server_hello_doneRADIUS_access_challengeEAP type = TLSClient’s TLSversion, sessionId,random no, ciphersuites supported. TLS version,sessionId,anotherrandom no,cipher suitesMasterKey = TLS-PRF(PreMasterKey, “master secret” || random1 || random2) || Unit 5 - 163```",
            "```\fExample – EAP-TLS (2)STAAP802. 1X/EAP responseEAP type = TLSTLS certificate, TLS client key exchange,TLS certificate verify, TLS change cipherspec, TLS finished802. 1X/EAP responseEAP type = TLSTLS change_cipher_spec, TLS finished802. 1X/EAP responseEAP type = TLSAP-RADIUS KeyASRADIUS Access Request/EAPResponse EAP type = TLSRADIUS access challengeEAP type = TLSRADIUS Access Request/EAPResponse EAP type = TLSPMK = TLS-PRF(MasterKey, “client EAP encryption” || random1 || random2)802. 1X/EAP SuccessRADIUS Access AcceptEAP type = TLS, PMK || Unit 5 - 164```",
            "```\fAuthentication SummaryAt the end of authentication phaseThe AS and STA have established a session if concrete EAP methoddoesThe AS and STA possess a mutually authenticated Master Key ifconcrete EAP method doesMaster Key represents decision to grant access based onauthenticationSTA and AS have derived PMKPMK is an authorization token to enforce access control decisionAS has distributed PMK to an AP (hopefully, to the STA’s AP) || Unit 5 - 165```",
            "```\f802. 1X Key Management802. 11i data protocols fail without “fresh” keysWant to use 802. 1X frameworkOriginal 802. 1X key management hopelessly broken, so redesigned by802. 11iNew model:Derive a Pairwise Master Key (PMK)AP and STA use PMK to derive Pairwise Transient Key (PTK)Use PTK to protect the link || Unit 5 - 166```",
            "```\fPairwise Key HierarchyA pre-shared key (PSK) is a secret key shared by the AP and a STAORMasterKey = TLS-PRF(PreMasterKey, “master secret” || random1 || random2)PMK = TLS-PRF(MasterKey, “client EAP encryption” || random1 || random2)Pairwise Transient Key (PTK) = EAPoL-PRF(PMK, AP Nonce || STA Nonce|| AP MACAddr || STA MAC Addr)Key Confirmation Key(KCK) – PTK bits 0–127Key Encryption Key (KEK) –PTK bits 128–255Temporal Key – PTK bits 256–n128 bits (CCMP) , 256 bits (TKIP) || Unit 5 - 167```",
            "```\fKey Management OverviewSTAAPASStep 1: Use RADIUS to push PMK from AS to APStep 2: Use PMK and 4-Way Handshake toderive, bind, and verify PTKStep 3: Use Group Key Handshake to send GTKfrom AP to STA || Unit 5 - 168```",
            "```\fStep 2: 4-Way HandshakeSTAAPPMKPMKPick Random ANonceEAPoL-Key(Reply Required, Unicast, ANonce)Pick Random SNonce, Derive PTK = EAPoL-PRF(PMK,ANonce | SNonce | AP MAC Addr | STA MAC Addr)EAPoL-Key(Unicast, SNonce, MIC, STA RSN IE)Derive PTKEAPoL-Key(Reply Required, Install PTK, Unicast,ANonce, MIC, AP RSN IE)EAPoL-Key(Unicast, MIC)Install TKused to secure data trafficInstall TK || Unit 5 - 169```",
            "```\fStep3: Group Key HandshakeSTAAPPTKPTKPick Random GNonce, Pick Random GTKEncrypt GTK with KEKEAPoL-Key(GNonce, MIC, GTK)Decrypt GTKEAPoL-Key(Group ACK, MIC)unblocked data trafficunblocked data traffic || Unit 5 - 170```",
            "```\fWhat is EAPoL?Extensive Authentication Protocol over Local Area Network (EAPOL) is partof EAP, but it is outlined inside the 802. 1x standard. This is because the 802. 1x standard allows certain EAP message typesto pass through an AP to the STA. This traffic (the EAP message ) is outlined with five frame types. This means that only these five frame types are allowed to passthrough an AP to a STA.  || Unit 5 - 171```",
            "```\fWhat is EAPoL?EAPOL frame formatPAEEthertypeProtocolversionPackettypePacketBody length2 Bytes1 Byte1 Byte2 Bytes= 0x88E8for EAPoL1. 2. 3. 4. 5. EAP-PacketEAPOL-StartEAPOL-LogoffEAPOL-KeyEAPOL-ASF-Alert0000 00000000 00010000 00100000 00110000 0100PacketbodyDescriptorType1 ByteDescriptorBodyVariable LengthEAPOL-Packet: used to identify the packet as an EAP packet. EAPOL-Start: used to begin an EAP conversation or an 802. 1x authentication. EAPOL-Logoff: used to end an EAP conversation or an 802. 1x authentication. EAPOL-Key: used to exchange keying information between the AP and the STA. EAPOL-Encapsulated-ASF-Alert: used to carry SNMP trap information out a non-802. 1xauthenticated port.  || Unit 5 - 172```",
            "```\fOne Last DetailIEEE 802. 11i uses a pseudorandom function (PRF) in many places. For example, it is used to generate nonces, to expand pairwise keys, and togenerate the GTK. The PRF is built on the use of HMAC-SHA-1. Recall that HMAC-SHA-1 takes a message (block of data)and a key of length at least 160 bits and produces a 160-bithash value. The IEEE 802. 11i PRF takes four parameters(a secret key K, an application specific text string A,some data specific to each case B, and the desirednumber of pseudorandom bits Len) as input,and produces the desired number of random bits. HMAC algorithm is run once, producing a 160-bit hash value. If more bits are required, HMAC is run again with the sameinputs, except that i is incremented each time,until the necessary number of bits is generated.  || Unit 5 - 173```",
            "```\fKey Management Summary4-Way HandshakeEstablishes a fresh pairwise key bound to STA and AP for this sessionProves liveness of peersDemonstrates there is no man-in-the-middle between PTK holders ifthere was no man-in-the-middle holding the PMKGroup Key Handshake provisions group key to all STAs || Unit 5 - 174```",
            "```\f802. 11i Protected Data Transfer PhaseIEEE 802. 11i defines two schemes for protecting 802. 11 MPDU datamessage integrity and confidentiality:the Temporal Key Integrity Protocol (TKIP), andthe Counter Mode-CBC MAC Protocol (CCMP). Temporal Key Integrity Protocol (TKIP)TKIP is designed to require only software changes to devices that areimplemented with the older wireless LAN security approach (i. e. , WEP). TKIP adds a 64-bit message integrity code (MIC),generated by an algorithm, called Michael, to the 802. 11 MACframe after the data field. TKIP provides data confidentiality by encrypting the MPDU plus MICvalue using RC4.  || Unit 5 - 175```",
            "```\f802. 11i Protected Data Transfer PhaseCounter Mode-CBC MAC Protocol (CCMP)Intended for newer IEEE 802. 11 devices that are equipped with thehardware to support this schemeUses the cipher block chaining message authentication code (CBC-MAC)with AES for integrityUses the CRT block cipher mode with AES for encryptionThe scheme uses a 48-bit packet number to construct a nonce toprevent replay attacks. Authenticated Encryption combining Counter mode (CTR) and CBCMAC, using a single keyAssumes 128 bit block cipher – IEEE 802. 11i uses AES || Unit 5 - 176```",
            "```\fCCM Mode OverviewUse CBC-MAC to compute a MIC on the plaintext header, length of theplaintext header, and the payloadUse CTR mode to encrypt the payloadCounter values 1, 2, 3, …Use CTR mode to encrypt the MICCounter value 0EncryptedHeaderPayloadMICAuthenticated || Unit 5 - 177```",
            "```\fCCM PropertiesCTR + CBC-MAC (CCM) based on a block cipherCCM provides integrity and confidentialityA CBC-MAC of the plaintext is appended to the plaintext to form anencoded plaintextThe encoded plaintext is encrypted in CTR modeCCM is packet orientedCCM can leave any number of initial blocks of the plaintextunencrypted || Unit 5 - 178```",
            "```\fData Transfer SummaryWEPTKIPCCMPCipherRC4RC4AESKey Size40 or 104 bits128 bits128 bits encryption,64 bit authKey Life24-bit IV, wrap48-bit IV48-bit IVPacket KeyConcat. Mixing FncNot NeededIntegrity (data)CRC-32MichaelCCMIntegrity (Header)NoneMichaelCCMReplayNoneUse IVUse IVKey Mgmt. NoneEAP-basedEAP-based || Unit 5 - 179```",
            "```\f802. 11i RSN - KeysAbbreviatiNameonPSKPre-Shared KeyDescription / PurposeBecomes the PMK in pre-shared key environments. PMKPair-wise Master KeyUsed with other inputs to derive the PTK. GMKGroup MasterKeyUsed with other inputs to derive the GTK. PTKPair-wise Transient KeyDerived from the PMK.  Comprises the EAPOL-KCK, EAPOL-KEK,and TK and (for TKIP) the MIC key. TKTemporal KeyUsed with TKIP or CCMP to provide confidentiality and integrityprotection for unicast user traffic. GTKGroupTemporal KeyMIC KeyEAPOL-KCKEAPOL-KEKWEP KeyDerived from the GMK.  Used to provide confidentiality andintegrity protection for multicast/broadcast user traffic. Message Integrity Code Used by TKIP’s Michael MIC to provide integrity protection ofKeymessages. EAPOL-Key Confirmation Used to provide integrity protection for key material distributedKeyduring the 4-Way Handshake. EAPOL-Key EncryptionKeyWired EquivalentPrivacyKeyUsed to ensure the confidentiality of the GTK and other keymaterial in the 4-Way Handshake. Used with WEP.  || Unit 5 - 180```",
            "```\f802. 11i Phases of Operation || Unit 5 - 181```",
            "```\f802. 11i RSN Cryptographic AlgorithmsAlgorithmServicesRobust Security Network (RSN)ConfidentialityTKIP(RC4)CCMP(AES)Integrity and AuthenticationHMACSHA-1HMACMD5TKIP(MichaelMIC)CCM(AES CBCMAC)KeyGenerationHMACSHA-1 || Unit 5 - 182```",
            "```\f802. 11i RSN Services and ProtocolsServicesAccessControlAuthentication andKey generationProtocolRobust Security Network (RSN)IEEE 802. 1xPort-basedaccesscontrolExtensibleAuthenticationProtocol (EAP)Confidentiality andIntegrityTKIPCCMP || Unit 5 - 183```"
        ]
    }
]