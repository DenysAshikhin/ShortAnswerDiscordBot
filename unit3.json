{
    "pptName": "Unit 3",
    "slides": [
        "```\fUnit 3Software-Defined Networking(SDN) || Unit 3 - 2```",
        "```\fUnit 3: Software-Defined Networking3. 1 The limitations of the traditional network architectures. 3. 2 The key requirements for an SDN architecture. 3. 3 The functions of the SDN data plane. 3. 4 The OpenFlow logical architecture and network protocol. 3. 5 The functions of the SDN control plane. 3. 6 An overview of OpenDaylight and REST APIs. 3. 7 An overview of the SDN application plane architecture. Reading: https://www. opennetworking. org/sdn-definition/ || Unit 3 - 3```",
        "```\f3. 1 The limitations of the traditional networkarchitectures || Unit 3 - 4```",
        "```\fEvolving Network RequirementsA number of trends are driving network providers and users toreevaluate traditional approaches to network architecture. These trends can be grouped under the categories ofdemand,Due to the increase in Cloud Computing, Big Data, Mobile traffic,IoT, etc. supply,Due to the increase in the capacity of the network transmissiontechnologies (e. g. , Ethernet, WiFi, 5G)traffic patterns.  || Unit 3 - 5```",
        "```\fSo …Traditional Network Architectures areInadequate!Why? || Unit 3 - 6```",
        "```\fTraditional Network Architectures are InadequateThe traditional internetworking approach is based on the TCP/IPprotocol architecture. Three significant characteristics of this approach are as follows:Two-level end system addressingRouting based on destinationDistributed autonomous control || Unit 3 - 7```",
        "```\fLimitationsThe Open Networking Foundation (ONF) cites four generallimitations of traditional network architectures:Static, complex architectureInconsistent policiesInability to scaleVendor dependence || Unit 3 - 8```",
        "```\f3. 2 The key requirements for an SDNarchitecture || Unit 3 - 9```",
        "```\fThe principal requirements for a modern networkingAdaptabilityNetworks must adjust and respond dynamically, based onapplication needs, business policy, and network conditions. AutomationPolicy changes must be automatically propagated so thatmanual work and errors can be reduced. MaintainabilityIntroduction of new features and capabilities (software upgrades,patches) must be seamless with minimal disruption of operations. Model managementNetwork management software must allow management of thenetwork at a model level, rather than implementing conceptualchanges by reconfiguring individual network elements. MobilityControl functionality must accommodate mobility, including mobileuser devices and virtual servers. Integrated securityNetwork applications must integrate seamless security as a coreservice instead of as an add-on solution. On-demand scalingImplementations must have the ability to scale up or scale downthe network and its services to support on-demand requests.  || Unit 3 - 10```",
        "```\fSDN and NFVTo provide adaptability and scalability, two key technologies that arerapidly being deployed by a variety of network service andapplication providers are:software-defined networking (SDN)Discussed in the subsequent slidesnetwork functions virtualization (NFV)Will be covered in SE4455 || Unit 3 - 11```",
        "```\fSoftware-defined networking (SDN)SDN is replacing the traditional networking model, it provides anenhanced level of flexibility to meet the needs of newer networkingand IT trends such as cloud, mobility, social networking, and video. In SDN, there are two elements involved in forwarding packetsthrough routersa control function, whichdecides the route for the flow totake and the relative priorityof traffic,and a data function, whichforwards data based oncontrol-function policy.  || Unit 3 - 12```",
        "```\fThe traditional network Vs.  the SDN approaches || Unit 3 - 13```",
        "```\fThe SDN approach || Unit 3 - 14```",
        "```\fThe SDN approach - The data planeThe data plane consists of physical switches and virtual switches,which are responsible for forwarding packets. The internal implementation of buffers, priority parameters, andother data structures should be uniform and open to the SDNcontrollers. This can be defined in terms of an open application programminginterface (API) between the control plane and the data plane(southbound API). The most prominent example of such an open API is OpenFlow.  || Unit 3 - 15```",
        "```\fThe SDN approach - The control planeSDN controllers can be implemented directly on a server or on avirtual server. OpenFlow or some other open API is used to control the switches inthe data plane. In addition, controllers use information about capacity and demandobtained from the networking equipment through which the trafficflows. SDN controllers also expose northbound APIs, which allowdevelopers and network managers to deploy a wide range of offthe-shelf and custom-built network applications. A number of vendors offer a Representational State Transfer(REST)-based API to provide a programmable interface to their SDNcontroller.  || Unit 3 - 16```",
        "```\fThe SDN approach - The application planeAt the application plane are a variety of applications that interactwith SDN controllers. SDN applications are programs that may use an abstract view of thenetwork for their decision-making goals. These applications convey their network requirements and desirednetwork behavior to the SDN controller via a northbound API. Examples of applications areenergy-efficient networking,security monitoring,access control, andnetwork management.  || Unit 3 - 17```",
        "```\fCharacteristics of SDNThe control plane is separated from the data plane; data planedevices become simple packet-forwarding devices. The control plane is implemented in a centralized controller or set ofcoordinated centralized controllers. The SDN controller has a centralized view of the network ornetworks under its control. The controller is portable software that can run on servers and iscapable of programming the forwarding devices based on acentralized view of the network. The network is programmable by applications running on top of theSDN controllers; the SDN controllers present an abstract view ofnetwork resources to the applications.  || Unit 3 - 18```",
        "```\fStandards-Developing OrganizationsUnlike some technology areas, such as Wi-Fi, there is no singlestandards body responsible for developing open standards for SDNand NFV. Rather, there is a large and evolving collection of standardsdeveloping organizations (SDOs), industrial consortia, and opendevelopment initiatives involved in creating standards and guidelinesfor SDN and NFV. The following table lists the main SDOs and other organizationsinvolved in the effort and the main outcomes so far produced.  || Unit 3 - 19```",
        "```\fSDN and NFVStandardsActivities || Unit 3 - 20```",
        "```\fOpenDaylightAn open source software activity under the auspices of the LinuxfoundationIts member companies provide resources to develop an SDNcontroller for a wide range of applicationsIs more in the nature of an open development initiative than aconsortiumAlso supports network programmability via southbound protocols, abunch of programmable network services, a collection ofnorthbound APIs, and a set of applications || Unit 3 - 21```",
        "```\fOpenStackIs an open source software project that aims to produce an opensource cloud operating systemProvides multitenant Infrastructure as a Service (IaaS) and aims tomeet the needs of public and private clouds regardless of size, bybeing simple to implement and massively scalableSDN technology is expected to contribute to its networking part,and to make the cloud operating system more efficient, flexible, andreliable || Unit 3 - 22```",
        "```\f3. 3 The functions of the SDN data plane || Unit 3 - 23```",
        "```\fThe SDN data planeReferred to as the resource layer or as the infrastructure layer,where network forwarding devices perform the transport andprocessing of data according todecisions made by the SDNcontrol plane. The important characteristic ofthe network devices in an SDNnetwork is that these devicesperform a simple forwardingfunction, without embeddedsoftware to make autonomousdecisions. The data plane network devicesalso called data plane networkelements or switches.  || Unit 3 - 24```",
        "```\fA simple forwarding function || Unit 3 - 25```",
        "```\fA simple forwarding functionThe principal functions of the network device are the following:Control support function: Interacts with the SDN control layer tosupport programmability via resource-control interfaces.  The switchcommunicates with the controller and the controller manages the switchvia the OpenFlow switch protocol. Data forwarding function: Accepts incoming data flows from othernetwork devices and forwards them along the data forwarding pathsthat have been computed and established by the SDN controlleraccording to the rules defined by the SDN applications. The network device can alter the packet header before forwarding,or discard the packet.  As shown, arriving packets may be placed inan input queue, awaiting processing by the network device, andforwarded packets are generally placed in an output queue,awaiting transmission.  || Unit 3 - 26```",
        "```\f3. 4 The OpenFlow logical architecture andnetwork protocol || Unit 3 - 27```",
        "```\fThe OpenFlowThere must be acommon logicalarchitecture in allnetwork devices to bemanaged by an SDNcontroller.  The SDNcontroller should see auniform logical switchfunctionalityA standard, secureprotocol is neededbetween the SDNcontroller and thenetwork device.  || Unit 3 - 28```",
        "```\fThe OpenFlowOpenFlow is both a protocol between SDN controllers and networkdevices and a specification of the logical structure of the networkswitch functionality.  || Unit 3 - 29```",
        "```\fThe OpenFlowOpenFlow is defined in the OpenFlow Switch Specification, publishedby the Open Networking Foundation (ONF). An SDN controller communicates with OpenFlow-compatibleswitches using the OpenFlow protocol running over TransportLayer Security (TLS). Each switch connects to other OpenFlow switches and, possibly, toend-user devices that are the sources and destinations of packetflows. On the switch side, the interface is known as an OpenFlowchannel.  These connections are via OpenFlow ports. An OpenFlow port also connects the switch to the SDN controller.  || Unit 3 - 30```",
        "```\fThe OpenFlow – Switch portsOpenFlow defines three types of ports:Physical port: Corresponds to a hardware interface of the switch.  Forexample, an Ethernet switch. Logical port: Does not correspond directly to a hardware interface ofthe switch.  May be defined in the switch using non-OpenFlow methods(for example, link aggregation groups, tunnels, loopback interfaces) andmay map to various physical ports. Reserved port: It specifies generic forwarding actions such as sendingto and receiving from the controller, flooding, or forwarding using nonOpenFlow methods, such as “normal” switch processing.  || Unit 3 - 31```",
        "```\fThe OpenFlow – TablesThe OpenFlow defines three types of tables:A flow table: matches incoming packets to a particular flow andspecifies what functions are to be performed on the packets.  There maybe multiple flow tables that operate in a pipeline fashion, as explainedsubsequently. A Group table: a flow table may direct a flow to a group table, whichmay trigger a variety of actions that affect one or more flows. A meter table: consists of meter entries that can trigger a variety ofperformance-related actions on a flow. Using the OpenFlow switch protocol, the controller can add, update,and delete flow entries in tables, both reactively (in response topackets) and proactively.  || Unit 3 - 32```",
        "```\fThe flow table(s)Each packet that enters an OpenFlow switch passes through one of moreflow tables.  Each flow table consists of a number of rows, called entries,consisting of seven components.  || Unit 3 - 33```",
        "```\fThe flow table – Seven ComponentsMatch fieldsUsed to select packets that match the values in the fields. PriorityRelative priority of table entries.  This is a 16-bit field with 0corresponding to the lowest priority.  In principle, there could be216 = 64k priority levels. CountersUpdated for matching packets.  The OpenFlow specification definesa variety of countersInstructionsInstructions to be performed if a match occursTimeoutsMaximum amount of idle time before a flow is expired by theswitch. Cookie64-bit data value chosen by the controller.  May be used by thecontroller to filter flow statistics, flow modification and flowdeletion; not used when processing packets. FlagsFlags alter the way flow entries are managed; for example, theflag OFPFF_SEND_FLOW_REM triggers flow removed messagesfor that flow entry.  || Unit 3 - 34```",
        "```\fThe flow table – The match fields componentIngress portThe identifier of the port on this switch on which thepacket arrived.  This may be a physical port or aswitch-defined virtual port.  Required in ingress tables. Egress portThe identifier of the egress port from action set. Required in egress tables. Ethernet source anddestination addressesEach entry can be an exact address, a bit maskedvalue for which only some of the address bits arechecked, or a wildcard value. Ethernet type fieldIndicates type of the Ethernet packet payload. IPVersion 4 or 6. IPv4 or IPv6 source address,and destination addressEach entry can be an exact address, a bit maskedvalue, a subnet mask value, or a wildcard value. TCP source and destinationportsExact match or wildcard value. UDP source and destinationportsExact match or wildcard value || Unit 3 - 35```",
        "```\fThe flow table – The countersCounterUsageReference Count (active entries)Per Flow Table32Duration (seconds)Per Flow Entry32Received PacketsPer Port64Transmitted PacketsPer Port64Duration (seconds)Per Port32Transmit PacketsPer Queue64Duration (seconds)Per Queue32Duration (seconds)Per Group32Duration (seconds)Per Meter32Bit length || Unit 3 - 36```",
        "```\fPacket flow through the processing pipelineA switch includes one or more flow tables.  If there is more than oneflow table, they are organized as a pipeline, with the tables labeledwith increasing numbers starting with zero. The use of multiple tables in a pipeline, rather than a single flowtable, provides the SDN controller with considerable flexibilityThe OpenFlow specification defines two stages of processing:Ingress processingEgress processing || Unit 3 - 37```",
        "```\fIngress processing alwayshappens, beginning with Table0, and uses the identity of theinput port.  Table 0 may be theonly table, in which case theingress processing is simplifiedto the processing performed onthat single table, and there isno egress processing. Egress processing is theprocessing that happens afterthe determination of the outputport.  It happens in the contextof the output port.  This stage isoptional.  If it occurs, it mayinvolve one or more tables.  || Unit 3 - 38```",
        "```\fThe ingress processingAt the final table in thepipeline forwarding toanother flow table is notan option. If and when a packet isfinally directed to anoutput port, theaccumulated action setis executed and thenthe packet is queued foroutput.  || Unit 3 - 39```",
        "```\fThe egress processingIf egress processing isassociated with aparticular output port,then after a packet isdirected to an outputport in the ingressprocess, the packet isdirected to the first flowtable of the egresspipelineThere is no group tableprocessing at the end ofthe egress pipeline.  || Unit 3 - 40```",
        "```\fThe use of multiple tablesThe use of multiple tables enables the breaking down of a single flow into anumber of parallel subflows. The use of multiple tables simplifies the processing in both the SDN controller andthe OpenFlow switch. Actions such as next hop that apply to the aggregate flow can be defined once by thecontroller and examined and performed once by the switch.  The addition of newsubflows at any level involves less setup. Therefore, the use of pipelined, multiple tables increases the efficiency of networkoperations, provides granular control, and enables the network to respond to realtime changes at the application, user, and session levels.  || Unit 3 - 41```",
        "```\fThe Group TablesDuring the pipeline processing, a flow table may direct a flow ofpackets to the group table rather than another flow table. The group table and group actions enable OpenFlow to represent aset of ports as a single entity for forwarding packets. Different types of groups are provided to represent differentforwarding abstractions, such as multicasting and broadcasting. Each group table consists of a number of rows, called group entries,consisting of four components.  || Unit 3 - 42```",
        "```\fThe Group TablesGroup identifier: A 32-bit unsigned integer uniquely identifying thegroup.  A group is defined as an entry in the group table. Group type: Determines group semantics, explained in the next slide. Counters: Updated when packets are processed by a group. Action buckets: An ordered list of action buckets, where each actionbucket contains a set of actions to execute. The action list is executed in sequence and generally ends with theOutput action, which forwards the packet to a specified port. The action list may also end with the Group action, which sends thepacket to another group.  || Unit 3 - 43```",
        "```\fThe Group Tables – Group TypeA group is designated as all, select, fast Failover, or indirect. all: executes all the buckets in the group. Each arriving packet is effectively cloned. Each bucket will designate a different output port, so that the incomingpacket is then transmitted on multiple output ports. This group is used for multicast or broadcast forwarding.  || Unit 3 - 44```",
        "```\fThe Group Tables – Group Typeselect:Executes one bucket in the group, based on a switch-computedselection algorithm (for example, hash on some user-configured tupleor simple round robin). The selection algorithm should implement equal load sharing or,optionally, load sharing based on bucket weights assigned by the SDNcontroller.  || Unit 3 - 45```",
        "```\fThe Group Tables – Group Typefast failover:Executes the first live bucket. Port liveness is managed by code outsideof the scope of OpenFlow and may have todo with routing algorithms. The buckets are evaluated in order, andthe first live bucket is selected. This group type enables the switch tochange forwarding without requiring around trip to the controller.  || Unit 3 - 46```",
        "```\fThe Group Tables – Group Typeindirect:Allows multiple packet flows (that is, multiple flowtable entries) to point to a common group identifier. This type provides for more efficient management bythe controller in certain situations. For example, suppose that there are 100 flow entries thathave the same match value in the IPv4 destination addressmatch field, but differ in some other match field, but all ofthem forward the packet to port X by including the actionOutput X on the action list.  We can instead replace thisaction with the action Group GID, where GID is the ID of anindirect group entry that forwards the packet to port X.  Ifthe SDN controller needs to change from port X to port Y, itis not necessary to update all 100 flow table entries.  All thatis required is to update the group entry.  || Unit 3 - 47```",
        "```\fOpenFlow ProtocolThe OpenFlow protocol describes message exchanges that take placebetween an OpenFlow controller and an OpenFlow switchTypically, the protocol is implemented on top of TLS, providing a secureOpenFlow channelThe OpenFlow protocol enables the controller to perform add, update, anddelete actions to the flow entries in the flow tablesIt supports three types of messages:Controller toswitchAsynchronousSymmetric || Unit 3 - 48```",
        "```\fOpenFlow MessagesMessageFeaturesConfigurationModify-StateRead-StatePacket-outBarrierRole-RequestAsynchronousConfigurationPacket-inFlow-RemovedPort-StatusRole-StatusController-StatusFlow-monitorHelloEchoErrorExperimenterDescriptionController-to-SwitchRequest the capabilities of a switch.  Switch responds with a features reply that specifies its capabilities. Set and query configuration parameters.  Switch responds with parameter settingsAdd, delete, and modify flow/group entries and set switch port properties. Collect information from switch, such as current configuration, statistics, and capabilities. Direct packet to a specified port on the switch. Barrier request/reply messages are used by the controller to ensure message dependencies have beenmet or to receive notifications for completed operations. Set or query role of the OpenFlow channel.  Useful when switch connects to multiple controllers. Set filter on asynchronous messages or query that filter.  Useful when switch connects to multiplecontrollers. AsynchronousTransfer packet to controller. Inform the controller about the removal of a flow entry from a flow table. Inform the controller of a change on a port. Inform controller of a change of its role for this switch from master controller to slave controller. Inform the controller when the status of an OpenFlow channel changes.  This can assist failover processingif controllers lose the ability to communicate among themselves. Inform the controller of a change in a flow table.  Allows a controller to monitor in real time the changes toany subsets of the flow table done by other controllersSymmetricExchanged between the switch and controller upon connection startup. Echo request/reply messages can be sent from either the switch or the controller, and must return anecho reply. Used by the switch or the controller to notify problems to the other side of the connection. For additional functionality.  || Unit 3 - 49```",
        "```\f3. 5 The functions of the SDN control plane || Unit 3 - 50```",
        "```\fSDN control plane architectureThe SDN control layer mapsapplication layer servicerequests into specificcommands and directives todata plane switches andsupplies applications withinformation about data planetopology and activity. The control layer isimplemented as a server orcooperating set of serversknown as SDN controllers. Let’s look at specific protocolsand standards implementedwithin the control plane || Unit 3 - 51```",
        "```\fSDN controllers functionsShortest path forwarding:Uses routing information collectedfrom switches to establish preferredroutes. Notification manager:Receives, processes, and forwardsan application events, such as alarmnotifications, security alerts, and state changes. Security mechanisms: Provides isolation and security enforcement betweenapplications and services. Topology manager: Builds and maintains switch interconnection topologyinformation. Statistics manager: Collects data on traffic through the switches. Device manager: Configures switch parameters and attributes and managesflow tables entries.  || Unit 3 - 52```",
        "```\fNetwork Operating System (NOS)The functionality provided by the SDN controller can be viewed as anetwork operating system (NOS)As with a conventional OS, NOS provides essential services,common application programming interfaces (APIs), and anabstraction of lower-layer elements to developersThe functions of an SDN NOS enable developers to define networkpolicies and manage networks without concern for the details of thenetwork device characteristicsNorthbound interfaces enable developers to create software thatis independent not only of data plane details but to a variety of SDNcontroller servers.  (more details later. . ) || Unit 3 - 53```",
        "```\fSDN controller implementationsA number of different initiatives, both commercial and open source,have resulted in SDN controller implementations:OpenDaylightOpen NetworkOperating System(ONOS)POXBeaconFloodlightRyuOnix || Unit 3 - 54```",
        "```\fSDN controller implementationsOpenDaylight: An open source platform for network programmability to enable SDN,written in Java.  OpenDaylight was founded by Cisco and IBM. Floodlight: An open source package developed by Big Switch Networks.  Both a webbased and Java based GUI are available and most of its functionality is exposed through aREST API. Open Network Operating System (ONOS): An open source SDN NOS, a nonprofiteffort funded and developed by a number of carriers, such as AT&T and NTT, and otherservice providers and supported by the Open Networking Foundation. Ryu: An open source component-based SDN framework developed by NTT Labs. Developed in python. POX: An open source OpenFlow controller that has been implemented by a number ofSDN developers and engineers.  POX has a well written API and documentation.  It alsoprovides a web-based graphical user interface (GUI) and is written in Python. Beacon: An open source package developed at Stanford.  Written in Java.  Beacon was thefirst controller that made it possible for beginner programmers to work with and create aworking SDN environment. Onix: Commercially available SDN controller, developed by VMWare, Google, and NTT.  || Unit 3 - 55```",
        "```\fSDN Controller InterfacesThe southbound interface provides the logicalconnection between the SDN controller andthe data plane switches. The most commonly implemented southboundAPI is OpenFlow. Other southbound interfaces include thefollowing:Open vSwitch Database Management Protocol(OVSDB): an open source software projectwhich implements virtual switching.  OVS usesOpenFlow for message forwarding in the controlplane for both virtual and physical ports. Forwarding and Control Element Separation(ForCES): An IETF effort that standardizes theinterface between the control plane and thedata plane for IP routers.  || Unit 3 - 56```",
        "```\fSDN Controller InterfacesThe northbound interface enables applications to access controlplane functions and services without needing to know the details ofthe underlying network switches. The northbound interface is more typically viewed as a software APIrather than a protocol. Base controller function APIs: These APIs expose the basicfunctions of the controller and are used by developers to createnetwork services. Network service APIs: These APIs expose network services to thenorth.  For example, Firewalls, Routings, and Optimizations. Northbound interface application APIs: These APIs exposeapplication-related services that are built on top of network services. For Example, security-related services.  || Unit 3 - 57```",
        "```\fSDN Controller - RoutingThe routing function comprises a protocol for collecting information aboutthe topology and traffic conditions of the network, and an algorithm fordesigning routes through the networkThere are two categories of routing protocols:• Concerned with discoveringthe topology of routerswithin an AS and thendetermining the best routeto each destination basedon different metricsInterior router protocols(IRPs) that operate withinan autonomous system (AS)Exterior router protocols(ERPs) that operate betweenautonomous systems• Need not collect as muchdetailed traffic information• Primary concern is todetermine reachability ofnetworks and end systemsoutside of the AS || Unit 3 - 58```",
        "```\fSDN Controller - RoutingTraditionally, the routing function is distributed among the routersin a network.  Each router is responsible for building up an image ofthe topology of the network.  For interior routing, each router as wellmust collect information about connectivity and delays and thencalculate the preferred route for each IP destination address. However, in an SDN-controlled network, the controller provides acentralized routing that can develop a consistent view of thenetwork state to calculate shortest paths. The data plane switches are relieved of the processing and storageburden associated with routing, leading to improved performance.  || Unit 3 - 59```",
        "```\fSDN Controller - RoutingThe centralized routing application performs two distinct functions:Link discoveryThe routing function needs to be aware of links between data planeswitchesMust be performed between a router and a host system and between arouter in the domain of this controller and a router in a neighboring domainDiscovery is triggered by unknown traffic entering the controller’s networkdomain either from an attached host or from a neighboring routerTopology managerMaintains the topology information for the network and calculates routes inthe networkRoute calculation involves determining the shortest path between two dataplane nodes or between a data plane node and a host || Unit 3 - 60```",
        "```\f3. 6 An overview of OpenDaylight and RESTAPIs || Unit 3 - 61```",
        "```\fThe OpenDaylight architecture || Unit 3 - 62```",
        "```\fService Abstraction Layer Model || Unit 3 - 63```",
        "```\fService Abstraction Layer ModelOpenDaylight is not tied to OpenFlow or any other specific southboundinterface.  This provides greater flexibility in constructing SDN networkconfigurations. The key element in this design is the SAL, which enables the controller tosupport multiple protocols on the southbound interface and provide consistentservices for controller functions and for SDN applications. The services manager maintains a registry that maps service requests to featurerequests.  Based on the service request, the SAL maps to the appropriate plug-inand thus uses the most appropriate southbound protocol to interact with a givennetwork device. All code in the OpenDaylight project is implemented in Java and is containedwithin its own Java Virtual Machine (JVM).  As such, it can be deployed on anyhardware and operating system platform that supports Java.  || Unit 3 - 64```",
        "```\fOpenDaylight - the Helium release || Unit 3 - 65```",
        "```\fOpenDaylight - the Helium releaseThe controller platform (exclusive of applications, which may also run on thecontroller) consists of a growing collection of dynamically pluggable modules,each of which performs one or more SDN-related functions and services. Five modules are considered base network service functions:Topology manager: A service for learning the network layout by subscribing to eventsof node addition and removal and their interconnection.  Applications requiring networkview can use this service. Statistics manager: Collects switch-related statistics, including flow statistics, nodeconnector, and queue occupancy. Switch manager: Holds the details of the data plane devices.  As a switch isdiscovered, its attributes (for example, what switch/router it is, software version,capabilities) are stored in a database by the switch manager. Forwarding rules manager: Installs routes and tracks next-hop information.  Works inconjunction with switch manager and topology manager to register and maintainnetwork flow state.  Applications using this need not have visibility of network devicespecifics. Host tracker: Tracks and maintains information about connected hosts.  || Unit 3 - 66```",
        "```\fREpresentational State Transfer (REST)An architectural style used to define APIsThis has become a standard way of constructing northbound APIsfor SDN controllersA REST API, or an API that is RESTful is not a protocol, language, orestablished standardIt is essentially six constraints that an API must follow to be RESTfulThe objective of these constraints is to maximize the scalability andindependence/interoperability of software interactions, and to providefor a simple means of constructing APIs || Unit 3 - 69```",
        "```\fREST ConstraintsThe six REST constraints are:• Client-server• Stateless• Cache• Uniform interface• Layered system• Code on demand || Unit 3 - 70```",
        "```\f(1) Client-ServerThis simple constraint dictates that interaction between applicationand server is in the client-server request/response styleThe principle defined for this constraint is the separation of userinterface concerns from data storage concernsThis separation allows client and server components to evolveindependently and supports the portability of server-side functionsto multiple platforms || Unit 3 - 71```",
        "```\f(2) Stateless ConstraintDictates that each request from a client to a server must contain allthe information necessary to understand the request and cannottake advantage of any stored context on the serverSimilarly, each response from the server must contain all thedesired information for that requestOne consequence is that any memory of a transaction is maintainedin a session state kept entirely on the clientAnother consequence is that if the client and server reside ondifferent machines, and therefore communicate via a protocol, thatprotocol need not be connection orientedREST typically runs over Hypertext Transfer Protocol (HTTP), whichis a stateless protocol || Unit 3 - 72```",
        "```\f(3) Cache ConstraintRequires that the data within a response to a request be implicitlyor explicitly labeled as cacheable or non-cacheableIf a response is cacheable, then a client cache is given the right toreuse that response data for later, equivalent requestsTherefore, subsequent requests for the same data can be handledlocally at the client, reducing communication overhead betweenclient and server || Unit 3 - 73```",
        "```\f(4) Uniform Interface ConstraintREST emphasizes a uniform interface between components,regardless of the specific client-server application API implementedusing RESTTo obtain a uniform interface, REST defines four interfaceconstraints:Identification of resourcesManipulation of resources through representationsSelf-descriptive messagesHypermedia as the engine of the application stateThe benefit of this constraint, for an SDN environment is thatdifferent applications can invoke the same controller service via aREST API || Unit 3 - 74```",
        "```\f(5) Layered System ConstraintA given function is organized in layers, with each layer only havingdirect interaction with the layers immediately above and belowThis is a fairly standard architecture approach for protocolarchitectures, OS design, and system services design || Unit 3 - 75```",
        "```\f(6) Code-on-Demand ConstraintREST allows client functionality to be extended by downloading andexecuting code in the form of applets or scriptsThis simplifies clients by reducing the number of features requiredto be pre-implementedAllowing features to be downloaded after deployment improvessystem extensibility || Unit 3 - 76```",
        "```\fThe APIfunctions forretrieving switchstatistics andparametersthat use the GETmessage type.  || Unit 3 - 77```",
        "```\fAPIs for Retrieving Switch and Updating Switch Statisticsand Parameters || Unit 3 - 78```"
    ]
}