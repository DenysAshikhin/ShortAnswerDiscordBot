{
    "pptName": "Unit 5",
    "slides": [
        "```\fUnit 5: Network Security Foundations5. 1Models for Network Security5. 2Information Security Principles5. 2Simple Security Protocols5. 3Authentication and TCP5. 4Secure Socket Layer (SSL/TLS)5. 5IP Security protocol (IPsec)5. 6802. 11 Wireless LAN SecurityReading: Chapters 31 and 32, Textbook – Forouzan || Unit 5 - 2```",
        "```\f5. 1 Models for Network Security || Unit 5 - 3```",
        "```\fNetwork Security Model 1TrustedpartyTrusted third partye. g. , key distributerInformation ChannelSecurity relatedtransformationMessageSecurity relatedtransformationSecureMessageBobSecureMessageMessageAliceSecretInformationSecretInformationTrudyModel 1: Information being transferred from one party to another over an insecurecommunications channel, in the presence of possible opponents.  || Unit 5 - 4```",
        "```\fNetwork Security Model 1Using this model requires us to:1.  Design a suitable algorithm for the security transformation2.  Generate the secret information (session keys) used by the algorithm3.  Develop methods to distribute and share the secret information4.  Specify a protocol enabling the principals to use the transformationand secret information for a security servicessuch as authentication, confidentiality, integrity, etc.  || Unit 5 - 5```",
        "```\fNetwork Security Model 2Trudy• Human (e. g. , hacker)• Software (e. g. , virus, worm)Access ChannelAliceGatekeeperfunction• Computer resources(e. g. , CPU, memory, I/O)• Data• Processes• SoftwareModel 2: is concerned with controlled access to information orresources on a computer system, in the presence of possibleopponents.  || Unit 5 - 6```",
        "```\fNetwork Security Model 2Using this model requires us to:Select appropriate gatekeeper functions to identify usersImplement security controls to ensure only authorised users accessdesignated information or resources || Unit 5 - 7```",
        "```\fProtocols DesignProtocols can be very subtleInnocuous change can make a significant difference in a protocolSecurity protocols are very subtleSeveral well-known security protocols have serious flawsIncluding IPSec, GSM and WEPAnd even if the protocol itself is not flawed, a particularimplementation can beIt is difficult to get protocols right…… therefore || Unit 5 - 8```",
        "```\fProtocols DesignWe need more understanding of the protocols in terms of:what does the protocol really achieve?does the protocol need more assumptions than another one?does the protocol do anything unnecessary that could be left outwithout weakening it?e. g. , does the protocol encrypt something that could be sent inclear?Let us now address the fundamental issues involved in the networksecurity protocols.  || Unit 5 - 9```",
        "```\f5. 2 Information Security Principles || Unit 5 - 10```",
        "```\fThe Importance of Information ProtectionInformation is an important asset, isn’t it?The more information you have at your command, the better you canadapt to the world around you. In business, information is often one of the most important assets acompany can possess. Information differentiates companies and provides leverage that helpsone company become more successful than another.  || Unit 5 - 11```",
        "```\fWhat is Cryptography?It’s all about controllingaccess to informationAccess to learning informationAccess to manipulateinformation || Unit 5 - 12```",
        "```\fAccess to InformationAlice, Bob and Trudy. Alice and Bob arecommunicatingAlice wants Bobto learn a message,“without Trudy learning it”AliceAlice can send outa bit string (the message) on the channel. Bob and Trudy both get itBobTrudy || Unit 5 - 13```",
        "```\fControlling Access to InformationThree algorithmsKey Generation: What Alice and Bobdo for creating the sharedsecret key (a bit string)Encryption: What Alice does withthe message and the key toobtain a “ciphertext”AlicekeyDecryption: What Bob does withthe ciphertext and the key to getthe message (the “plaintext”)out of itBobkeyTrudyAll of these are computationsWhat are the attributes of these computations? (later. . ) || Unit 5 - 14```",
        "```\fCrypto – terms and definitionsCryptology ⎯ The art and science of making and breaking “secretcodes”Cryptography ⎯ making “secret codes”Cryptanalysis ⎯ breaking “secret codes”Crypto ⎯ all of the above (and more), the precise meaning shouldbe clear from the context.  || Unit 5 - 15```",
        "```\fHow to Speak CryptoA cipher or cryptosystem is used to encrypt the plaintextThe result of encryption is ciphertextWe decrypt ciphertext to recover plaintextA key is used to configure a cryptosystemA symmetric key cryptosystem uses the same key to encrypt as todecryptA public key cryptosystem (AKA asymmetric key cryptosystem) usesa public key to encrypt and a private key to decrypt (sign) || Unit 5 - 16```",
        "```\fGeneral idea of a symmetric-key cipherAliceBob || Unit 5 - 17```",
        "```\fGeneral idea of public-key cryptosystemBobAlice || Unit 5 - 18```",
        "```\fDigital signature processBobAlice(M, S) || Unit 5 - 19```",
        "```\fFeasible ComputationIn analyzing complexity of algorithms: we rate the computationalcomplexity grows with input sizee. g.  Can do sorting in O(n log n)Only the rough rate considered. The exact time depends on the technology“Polynomial time” (O(n), O(n2), O(n3), . . . ) considered feasible || Unit 5 - 20```",
        "```\fInfeasible Computation“Super-Polynomial time” considered infeasibleFor example: O(2n), O(2√n)i. e. , as n grows, quickly becomes“infeasibly large”Can we make breakingsecurity infeasible for Trudy?What is n (that can grow)?Message size?(We need security evenif sending only one bit!) || Unit 5 - 21```",
        "```\fCryptoBasic assumptionThe system is completely known to the attackerOnly the key is secretAlso known as Kerckhoffs’ PrincipleCrypto algorithms are not secretWhy do we make this assumption?Experience has shown that secret algorithms are weak whenexposedSecret algorithms never remain secretBetter to find weaknesses before hand || Unit 5 - 22```",
        "```\fSymmetric Key Crypto NotationsP = plaintext blockC = ciphertext blockEncrypt P with key K to get ciphertext CC = E(P , K)Decrypt C with key K to get plaintext PP = D(C, K)Note thatP = D(E(P , K), K) and C = E (D(C, K), K) || Unit 5 - 23```",
        "```\fPublic Key Cypto NotationsSign message M with Alice’s private key:[M]AliceEncrypt message M with Alice’s public key:{M}AliceThen{[M]Alice}Alice = M[{M}Alice]Alice = M || Unit 5 - 24```",
        "```\f5. 2 Simple Security Protocols || Unit 5 - 25```",
        "```\fSecure Entry to NSAEmployees are given a badge that they must wear at all timeswhen they are in the secure facility. To enter the building:1. Insert badge into reader2. Enter PIN3. Correct PIN?Yes? EnterNo? Get shot by security guard || Unit 5 - 26```",
        "```\fATM Machine ProtocolWhen you withdraw money from an ATM machine, the protocol isvirtually identical to the secure entry protocol of the NSA1. Insert ATM card2. Enter PIN3. Correct PIN?Yes? Conduct your transaction(s)No? Machine eats your card || Unit 5 - 27```",
        "```\fIdentify Friend or Foe (IFF)The military has a need for many specialized security protocols.  Onesuch class of protocols is used to identify friend or foe, or IFF. Example:Consider the protocol that was used by the South African AirForce, or SAAF, when fighting in Angola. SAAF were based in Namibia, and they were fighting soldiersstationed in Angola, who were flying Soviet MiG aircraft. RussianMIGAngola || Unit 5 - 28```",
        "```\fIdentify Friend or Foe (IFF)1.  When the SAAF radar detected an aircraft approaching, a randomnumber, or challenge, N was sent to the aircraft. 2.  All SAAF aircraft knew a key K that they used to encrypt thechallenge, E(N,K), which was then sent back to the radar station. 2.  E(N,K)SAAFFighter1.  NNamibia || Unit 5 - 29```",
        "```\fMIG in the Middle3.  NSAAFfighter4.  E(N,K)Angola2.  N5.  E(N,K)RussianMiG6.  E(N,K)1.  NNamibia || Unit 5 - 30```",
        "```\fAuthentication Protocols || Unit 5 - 31```",
        "```\fAuthenticationAlice must prove her identity to BobAlice and Bob can be humans or computersMay also require Bob to prove he’s Bob (mutual authentication)May also need to establish a session keyMay have other requirements, such asUse only public keysUse only symmetric keysUse only a hash function || Unit 5 - 32```",
        "```\fAuthenticationAuthentication on a stand-alone computer is relatively simpleMain concern is an attack on authentication softwareAuthentication over a network is much more complexAttacker can passively observe messagesAttacker can replay messagesActive attacks may be possible (insert, delete, change messages) || Unit 5 - 33```",
        "```\fSimple Authentication“I’m Alice”Prove itMy password is “frank”AliceBobSimple and may be OK for standalone systemBut inefficient and insecure for networked systemSubject to a replay attack (next 2 slides)Bob must know Alice’s password || Unit 5 - 34```",
        "```\fAuthentication Attack“I’m Alice”Prove itMy password is “frank”BobAliceTrudy || Unit 5 - 35```",
        "```\fAuthentication Attack“I’m Alice”Prove itMy password is “frank”TrudyBobThis is a replay attackHow can we prevent a replay? || Unit 5 - 36```",
        "```\fSimple AuthenticationI’m Alice, My password is “frank”AliceBobMore efficient…But same problem as previous version || Unit 5 - 37```",
        "```\fBetter Authentication“I’m Alice”Prove ith(Alice’s password)AliceBobBetter since it hides Alice’s passwordFrom both Bob and attackersBut still subject to replay || Unit 5 - 38```",
        "```\fChallenge-ResponseTo prevent replay, challenge-response can be usedSuppose Bob wants to authenticate AliceChallenge sent from Bob to AliceOnly Alice can provide the correct responseChallenge chosen so that replay is not possibleHow to accomplish this?Password is something only Alice should know…For freshness, a “number used once” (or nonce) || Unit 5 - 39```",
        "```\fChallenge-Response“I’m Alice”Nonceh(Alice’s password, Nonce)AliceBobNonce is the challengeThe hash is the responseNonce prevents replay, insures freshnessPassword is something Alice knowsNote that Bob must know Alice’s password || Unit 5 - 40```",
        "```\fChallenge-Response“I’m Alice”NonceAliceSomething that could only befrom Alice (and Bob can verify)BobWhat can we use to achieve this?Hashed pwd works, crypto might be better || Unit 5 - 41```",
        "```\fChallenge-Response“I’m Alice”NonceAliceSomething that could only befrom Alice (and Bob can verify)Bob || Unit 5 - 42```",
        "```\fSymmetric Key NotationEncrypt plaintext P with key KC = E(P,K)Decrypt ciphertext C with key KP = D(C,K)Here, we are concerned with attacks on protocols, not directly onthe cryptoWe assume that crypto algorithm is secure || Unit 5 - 43```",
        "```\fSymmetric Key AuthenticationAlice and Bob share symmetric key KABKey KAB known only to Alice and BobAuthenticate by proving knowledge of shared symmetric keyHow to accomplish this?Must not reveal keyMust not allow replay attack || Unit 5 - 44```",
        "```\fChallenge-Response“I’m Alice”NonceAliceSomething that could only befrom Alice (and Bob can verify)BobLet us consider Symmetric Key || Unit 5 - 45```",
        "```\fAuthentication with Symmetric Key“I’m Alice”Alice, KABE(R,KAB)Bob, KABSecure method for Bob to authenticate AliceAlice does not authenticate BobCan we achieve mutual authentication? || Unit 5 - 46```",
        "```\fMutual Authentication?“I’m Alice”, RE(R,KAB)AliceE(R,KAB)BobWhat’s wrong with this protocol?“Alice” could be Trudy (or anybody else)! || Unit 5 - 47```",
        "```\fMutual AuthenticationSince we have a secure one-way authentication protocol…The obvious thing to do is to use the protocol twiceOnce for Bob to authenticate AliceOnce for Alice to authenticate BobThis has to work… || Unit 5 - 48```",
        "```\fMutual Authentication“I’m Alice”, RARB, E(RA,KAB)AliceE(RB,KAB)BobThis provides mutual authentication……or does it? Do you still remember the MiG-in-the-Middle attack || Unit 5 - 49```",
        "```\fMutual Authentication Attack1.  “I’m Alice”, RA2.  RB, E(RA,KAB)BobTrudy3.  “I’m Alice”, RB4.  RC, E(RB,KAB)TrudyBob || Unit 5 - 50```",
        "```\fMutual AuthenticationOur one-way authentication protocol not secure for mutualauthenticationProtocols are subtle!The “obvious” thing may not be secureAlso, if assumptions or environment changes, protocol maynot workThis is a common source of security failureFor example, Internet protocols || Unit 5 - 51```",
        "```\fSymmetric Key Mutual Authentication“I’m Alice”, RARB, E(“Bob”,RA,KAB)E(“Alice”,RB,KAB)AliceBobDo these “insignificant” changes help?Yes! || Unit 5 - 52```",
        "```\fChallenge-Response“I’m Alice”NonceAliceSomething that could only befrom Alice (and Bob can verify)BobLet us consider Public Key || Unit 5 - 53```",
        "```\fPublic Key NotationEncrypt M with Alice’s public key: {M}AliceSign M with Alice’s private key: [M]AliceThen[{M}Alice ]Alice = M{[M]Alice }Alice = MAnybody can do public key operationsOnly Alice can use her private key (sign) || Unit 5 - 54```",
        "```\fPublic Key Authentication“I’m Alice”{R}AliceAliceBobIs this secure?Trudy can get Alice to decrypt anything!Must have two key pairs || Unit 5 - 55```",
        "```\fPublic Key Authentication“I’m Alice”[R]AliceAliceBobIs this secure?Trudy can get Alice to sign anything!Must have two key pairs || Unit 5 - 56```",
        "```\fNote on Public KeysNever use the same key pair for encryption and signingOne key pair for encryption/decryptionA different key pair for signing/verifying signatures || Unit 5 - 57```",
        "```\fSession KeyIn addition to authentication, a session key is often requiredOne symmetric key is used per sessionCan we authenticate and establish a shared symmetric key?In some cases, we may also require perfect forward secrecy(PFS)Discussed later… || Unit 5 - 58```",
        "```\fAuthentication & Session KeyEncrypt only“I’m Alice”{R,K}Alice{R +1,K}BobAliceBobIs this secure?OK for key, but no mutual authentication || Unit 5 - 59```",
        "```\fAuthentication & Session KeySign only“I’m Alice” , R[R,K]BobAlice[R +1,K]AliceBobIs this secure?Mutual authentication but key is not secret! || Unit 5 - 60```",
        "```\fAuthentication & Session KeySign and Encrypt“I’m Alice” , R{[R,K]Bob}Alice{[R +1,K]Alice}BobAliceBobIs this secure?Seems to be OKMutual authentication and session key! || Unit 5 - 61```",
        "```\fAuthentication & Session KeyEncrypt and Sign“I’m Alice” , R[{R,K}Alice]Bob[{R +1,K}Bob]AliceAliceBobIs this secure?Seems to be OKAnyone can see {R,K}Alice and {R +1,K}Bob || Unit 5 - 62```",
        "```\fPerfect Forward SecrecyThe concern…Alice encrypts message with shared key KAB and sendsciphertext to BobTrudy records ciphertext and later attacks Alice’s (or Bob’s)computer to find KABThen Trudy decrypts recorded messagesPerfect forward secrecy (PFS): Trudy cannot later decrypt recordedciphertextEven if Trudy gets key KAB or other secret(s)Is PFS possible? || Unit 5 - 63```",
        "```\fPerfect Forward SecrecySuppose Alice and Bob share key KABFor perfect forward secrecy, Alice and Bob cannot use KAB toencryptInstead they must use a session key KS and forget it after it’s usedProblem: How can Alice and Bob agree on session key KS andensure PFS? || Unit 5 - 64```",
        "```\fDiffie-HellmanInvented by Whitfield Diffie and Martin HellmanA “key exchange” algorithmUsed to establish a shared symmetric keyNot for encrypting or signingSecurity rests on difficulty of discrete logarithm problem:given g, p, and (gk mod p)find kThe discrete log problem is very difficult to solve || Unit 5 - 65```",
        "```\fDiffie-HellmanLet p be prime, let g be a generatorFor any x  {1,2,…,p-1} there is n such thatx = gn mod pThe process: (g and p are public)Alice selects secret value aBob selects secret value bAlice sends ga mod p to BobBob sends gb mod p to AliceBoth compute shared secret gab mod pShared secret can be used as symmetric key || Unit 5 - 66```",
        "```\fDiffie-Hellman - key exchangePublic: g and pSecret: Alice’s exponent a, Bob’s exponent bga mod pgb mod pAlice, aBob, b(ga)b = gab mod pAlice computes (gb) a = gba = gab mod pBoth could use K = gab mod p as symmetric keyBob computes || Unit 5 - 67```",
        "```\fDiffie-HellmanSuppose that Bob and Alice use gab mod p as a symmetric keyTrudy can see ga mod p and gb mod pNote ga gb mod p = ga+b mod p  gab mod pIf Trudy can find a or b, the system is brokenIf Trudy can solve discrete log problem, then she can find a or b || Unit 5 - 68```",
        "```\fDiffie-Hellman - Example 1If Alice and Bob agree on the values:p = 113 g = 23then Alice selects the secret value 4 and sends Bob the value234 mod 113 = 53While Bob selects the secret value 11 and sends Alice the value2311 mod 113 = 27They both calculate the common key:Bob5311 mod 113 = 2Alice274 mod 113 = 2 || Unit 5 - 69```",
        "```\fExample 2If Alice and Bob agree on the values:p = 76825670157115949022871g = 129633then Alice selects the secret value 1567and Bob selects his secret value 3001So Alice sends 3748860625118221776574 to Bob andBob sends 34126923917580261813405 to Alice. They both calculate the common key:32347879715377627749156 || Unit 5 - 70```",
        "```\fDiffie-Hellman - MiM attackSubject to man-in-the-middle (MiM) attackAlice, aga mod pgt mod pgt mod pgb mod pTrudy, tBob, bTrudy shares secret gat mod p with AliceTrudy shares secret gbt mod p with BobAlice and Bob don’t know Trudy exists! || Unit 5 - 71```",
        "```\fDiffie-HellmanHow to prevent MiM attack?Encrypt DH exchange with symmetric keyEncrypt DH exchange with public keySign DH values with private keyYou MUST be aware of MiM attack on Diffie-Hellman || Unit 5 - 72```",
        "```\fPerfect Forward SecrecyCan use Diffie-Hellman for PFSRecall Diffie-Hellman: public g and pga mod pgb mod pAlice, aBob, bBut Diffie-Hellman is subject to MiMHow to get PFS and prevent MiM? || Unit 5 - 73```",
        "```\fPerfect Forward SecrecyE(ga mod p, KAB)E(gb mod p, KAB)Alice, aBob, bSession key KS = gab mod pAlice forgets a, Bob forgets bEphemeral Diffie-HellmanNot even Alice and Bob can later recover KSOther ways to do PFS? || Unit 5 - 74```",
        "```\fMutual Authentication, Session Keyand PFS“I’m Alice”, RARB, [{RA, gb mod p}Alice]Bob[{RB, ga mod p}Bob]AliceAliceBobSession key is K = gab mod pAlice forgets a and Bob forgets bIf Trudy later gets Bob’s and Alice’s secrets, she cannotrecover session key K || Unit 5 - 75```",
        "```\fTimestampsA timestamp T is the current timeTimestamps used in many security protocols (Kerberos, forexample)Timestamps reduce number of messagesLike a nonce that both sides know in advanceClocks never exactly the same, so must allow for clock skew ⎯ riskof replayHow much clock skew is enough? || Unit 5 - 76```",
        "```\fPublic Key Authentication with Timestamp TSign and Encrypt“I’m Alice”, {[T,K]Alice}Bob{[T +1,K]Bob}AliceAliceBobIs this secure?Seems to be OK || Unit 5 - 77```",
        "```\fPublic Key Authentication with Timestamp TEncrypt and Sign“I’m Alice”, [{T,K}Bob]Alice[{T +1,K}Alice]BobAliceBobIs this secure?Trudy can use Alice’s public key to find{T,K}Bob so what… || Unit 5 - 78```",
        "```\fPublic Key Authentication with Timestamp TEncrypt and Sign“I’m Trudy”, [{T,K}Bob]Trudy[{T +1,K}Trudy]BobTrudyBobTrudy obtains Alice-Bob session key KNote: Trudy must act within clock skew || Unit 5 - 79```",
        "```\fPublic Key AuthenticationSign and encrypt with nonce…SecureEncrypt and sign with nonce…SecureSign and encrypt with timestamp…SecureEncrypt and sign with timestamp…InsecureProtocols can be subtle! || Unit 5 - 80```",
        "```\fPublic Key Authentication with Timestamp T(Secure) Encrypt and Sign“I’m Alice”, [{T,K}Bob]Alice[{T +1}Alice]BobAliceBobIs this “encrypt and sign” secure?Yes, seems to beDoes “sign and encrypt” also work here? || Unit 5 - 81```",
        "```\fMutual Authentication, with Public KeySign and encrypt with nonce…SecureEncrypt and sign with nonce…SecureSign and encrypt with timestamp…SecureEncrypt and sign with timestamp…Secure || Unit 5 - 82```",
        "```\f5. 3 Authentication and TCP || Unit 5 - 83```",
        "```\fTCP-based AuthenticationTCP not intended for use as an authentication protocolBut IP address in TCP connection often used for authenticationOne mode of IPSec uses IP address for authenticationThis can cause problems || Unit 5 - 84```",
        "```\fTCP 3-way HandshakeSYN, SEQ aSYN-ACK a+1, SEQ bACK b+1, dataAliceBobRecall the TCP three way handshakeInitial SEQ numbers, SEQ a and SEQ bSupposed to be randomIf not… || Unit 5 - 85```",
        "```\fTCP Authentication AttackBobTrudy5. 5. 5. 5. Alice || Unit 5 - 86```",
        "```\fTCP Authentication AttackTrudy cannot see what Bob sends, but she can send packets to Bob,while posing as AliceTrudy must prevent Alice from receiving Bob’s packets (or elseconnection will terminate)If password (or other authentication) required, this attack failsIf TCP connection is relied on for authentication, then attack cansucceedBad idea to rely on TCP for authentication || Unit 5 - 87```",
        "```\fBest Authentication Protocol?What is best, depends on many factors…The sensitivity of the applicationThe delay that is tolerableThe cost (computation) that is tolerableWhat crypto is supportedPublic key, symmetric key, hash functionsIs mutual authentication required?Is a session key required?Is PFS a concern?, etc.  || Unit 5 - 88```",
        "```\f5. 4 Secure Socket Layer (SSL/TLS) || Unit 5 - 89```",
        "```\fSocket layer“Socket layer” livesbetween application andtransport layersSSL usually lies betweenHTTP and TCPSocket“layer”applicationUsertransportOSnetworklinkNICphysical || Unit 5 - 90```",
        "```\fWhat is SSL?SSL (and IEEE standard known as TLS) is the protocol used for mostsecure transactions over the InternetFor example, if you want to buy a book at amazon. com…You want to be sure you are dealing with Amazon(authentication)Your credit card information must be protected in transit(confidentiality and/or integrity)As long as you have money, Amazon doesn’t care who you are(authentication need not be mutual) || Unit 5 - 91```",
        "```\fSimple SSL-like ProtocolI’d like to talk to you securelyHere’s my certificate{KAB}BobAliceprotected HTTPBobIs Alice sure she’s talking to Bob?Is Bob sure he’s talking to Alice? || Unit 5 - 92```",
        "```\fSimplified SSL ProtocolCan we talk?, cipher list, RAcertificate, cipher, RB{S}Bob, E(h(msgs,CLNT,K),K)Aliceh(msgs,SRVR,K)Data protected with key KBobS is pre-master secretK = h(S,RA,RB)msgs = all previous messagesCLNT and SRVR are string constants || Unit 5 - 93```",
        "```\fSimplified SSL Protocol1. Alice informs Bob that she would like to establish an SSL connection, andshe passes a list of ciphers that she supports, along with a nonce RA. 2. Bob responds with his certificate, he selects one of the ciphers from theciphers list that Alice sent in message one, and he sends a nonce RB. 3. Alice sends the S that she generated, along with a hash that is encryptedwith the key K.  In this hash, “msgs” includes all previous messages andCLNT is a literal string.  The hash is used to verify that the previousmessages have been received correctly4. Bob responds with a similar hash.  Alice can thereby verify that Bobreceived the messages correctly, and, more importantly, she canauthenticate Bob, since only Bob could have decrypted S, which isrequired to generate the key K.  || Unit 5 - 94```",
        "```\fSSL Keys6 “keys” derived from K = hash(S,RA,RB)2 encryption keys: 1 for sending and 1 for receiving data2 integrity keys: 1 for sending and 1 for receiving data2 IVs: 1 for sending and 1 for receiving dataQ: Why different keys in each direction?A: may help to prevent certain types of replay attacks.  || Unit 5 - 95```",
        "```\fSSL AuthenticationAlice authenticates Bob, not vice-versaHow does client authenticate server?Why does server not authenticate client?Mutual authentication is possible: Bob sends certificate request inmessage 2This requires client to have certificateIf server wants to authenticate client, server could insteadrequire (encrypted) password || Unit 5 - 96```",
        "```\fSimplified SSL ProtocolCan we talk?, cipher list, RAcertificate, cipher, RB{S}Bob, E(h(msgs,CLNT,K),K)h(msgs,SRVR,K)AliceclientData protected with key KBobserver || Unit 5 - 97```",
        "```\fSSL MiM AttackAliceRAcertificateT, RB{S1}Trudy,E(X1,K1)h(Y1,K1)E(data,K1)TrudyRAcertificateB, RB{S2}Bob,E(X2,K2)h(Y2,K2)E(data,K2)BobQ: What prevents this MiM attack?A: Bob’s certificate must be signed by a certificate authority(such as Verisign)What does Web browser do if signature not valid?What does user do if signature is not valid? || Unit 5 - 98```",
        "```\fSSL Sessions vs ConnectionsSSL session is established as shown on previous slidesSSL designed for use with HTTP 1. 0HTTP 1. 0 usually opens multiple simultaneous (parallel) connectionsSSL session establishment is costlyDue to public key operationsSSL has an efficient protocol for opening new connections given anexisting session || Unit 5 - 99```",
        "```\fSSL Connectionsession-ID, cipher list, RAsession-ID, cipher, RB,h(msgs,SRVR,K)h(msgs,CLNT,K)AliceProtected dataBobAssuming SSL session existsSo S is already known to Alice and BobBoth sides must remember session-IDAgain, K = h(S,RA,RB)No public key operations! (relies on known S) || Unit 5 - 100```",
        "```\fSSL vs IPSecIPSec ⎯ will be given in next slidesLives at the network layer (part of the OS)Has encryption, integrity, authentication, etc. Is overly complex (including serious flaws)SSL (and IEEE standard known as TLS)Lives at socket layer (part of user space)Has encryption, integrity, authentication, etc. Has a simpler specification || Unit 5 - 101```",
        "```\fSSL vs IPSecIPSec implementationRequires changes to OS, but no changes to applicationsSSL implementationRequires changes to applications, but no changes to OSSSL built into Web application early on (Netscape)IPSec used in VPN “virtual private network” applications (secure tunnel)Reluctance to put more research and build more applications for SSLReluctance to use IPSec due to complexity and interoperability issuesResult? Internet less secure than it should be! || Unit 5 - 102```",
        "```\f5. 5 IP Security protocol (IPsec) || Unit 5 - 103```",
        "```\fIPSec and SSLIPSec lives at thenetwork layerIPSec is transparentto applicationsSSLIPSecapplicationUsertransportOSnetworklinkNICphysical || Unit 5 - 104```",
        "```\fIPSec and ComplexityIPSec is a complex protocolOver-engineeredLots of generally useless extra featuresFlawedSome serious security flawsInteroperability is serious challengeDefeats the purpose of having a standard!ComplexDid I mention, it’s complex? || Unit 5 - 105```",
        "```\fIKE and ESP/AHTwo parts to IPSecIKE: Internet Key ExchangeMutual authenticationEstablish shared symmetric keyTwo “phases” ⎯ like SSL session/connectionESP/AHESP: Encapsulating Security Payload ⎯ for encryption and/orintegrity of IP packetsAH: Authentication Header ⎯ integrity only || Unit 5 - 106```",
        "```\fIKE || Unit 5 - 107```",
        "```\fIKEIKE has 2 phasesPhase 1 ⎯ IKE security association (SA)Phase 2 ⎯ IPSec security associationPhase 1 is comparable to SSL sessionPhase 2 is comparable to SSL connectionNot an obvious need for two phases in IKEIf multiple Phase 2’s do not occur, then it is more expensive to havetwo phases! || Unit 5 - 108```",
        "```\fIKE Phase 1Four different “key” optionsPublic key encryption (original version)Public key encryption (improved version)Public key signatureSymmetric keyFor each of these, two different “modes”Main modeAggressive modeThere are 8 versions of IKE Phase 1!Evidence that IPSec is over-engineered? || Unit 5 - 109```",
        "```\fIKE Phase 1We’ll discuss 6 of 8 phase 1 variantsPublic key signatures (main and aggressive modes)Symmetric key (main and aggressive modes)Public key encryption (main and aggressive)Why public key encryption and public key signatures?Always know your own private keyMay not (initially) know other side’s public key || Unit 5 - 110```",
        "```\fIKE Phase 1Uses ephemeral Diffie-Hellman to establish session keyAchieves perfect forward secrecy (PFS)Let a be Alice’s Diffie-Hellman exponentLet b be Bob’s Diffie-Hellman exponentLet g be generator and p primeRecall p and g are public || Unit 5 - 111```",
        "```\fIKE Phase 1: Digital Signature (Main Mode)IC, CPIC,RC, CSIC,RC, ga mod p, RAIC,RC, gb mod p, RBAliceIC,RC, E(“Alice”, proofA, K)IC,RC, E(“Bob”, proofB, K)BobCP = crypto proposed, CS = crypto selectedIC = initiator “cookie”, RC = responder “cookie”K = h(IC,RC,gab mod p,RA,RB)SKEYID = h(RA, RB, gab mod p)proofA = [h(SKEYID,ga mod p, gb mod p,IC,RC,CP,“Alice”)]Alice || Unit 5 - 112```",
        "```\fIKE Phase 1: Digital Signature (MainMode)In the first message Alice provides information on the ciphers that shesupports along with a “cookie” . In message two, Bob selects from Alice’s crypto proposal and sends thecookies. The third message includes a nonce and Alice’s Diffie-Hellman value. Bob responds similarly in message four, providing a nonce and his DiffieHellman value. In the final two messages, Alice and Bob authenticate each other usingdigital signatures. A passive attacker cannot recognize Alice or Bob’s identity, so this protocolprovides anonymity. In the aggressive mode version of digital signatures, there is no attempt tohide the identities of Alice or Bob.  || Unit 5 - 113```",
        "```\fIKE Phase 1: Public Key Signature (Aggressive Mode)IC, “Alice”, ga mod p, RA, CPIC,RC, “Bob”, RB,gb mod p, CS, proofBAliceIC,RC, proofABobMain difference from main modeNot trying to protect identitiesCannot negotiate g or p || Unit 5 - 114```",
        "```\fMain vs Aggressive ModesFor public key signature authenticationPassive attacker knows identities of Alice and Bob inaggressive modeActive attacker can determine Alice’s and Bob’s identity inmain mode || Unit 5 - 115```",
        "```\fIC, CPIC,RC, CSIC,RC, ga mod p, RAIC,RC, gb mod p, RBAliceIC,RC, E(“Alice”, proofA, K)IC,RC, E(“Bob”, proofB, K)BobCP = crypto proposed, CS = crypto selectedIC = initiator “cookie”, RC = responder “cookie”K = h(IC,RC,gab mod p,RA,RB)SKEYID = h(RA, RB, gab mod p)proofA = [h(SKEYID,ga,gb,IC,RC,CP,“Alice”)]Alice || Unit 5 - 116```",
        "```\fIKE Phase 1: Symmetric Key (Main Mode)IC, CPIC,RC, CSIC,RC, ga mod p, RAAliceIC,RC, gb mod p, RBIC,RC, E(“Alice”, proofA, K)IC,RC, E(“Bob”, proofB, K)BobSame as signature mode exceptKAB = symmetric key shared in advanceK = h(IC,RC,gab mod p,RA,RB,KAB)SKEYID = h(K, gab mod p)proofA = h(SKEYID ,ga mod p ,gb mod p,IC,RC,CP,“Alice”) || Unit 5 - 117```",
        "```\fProblems with Symmetric Key (Main Mode)Here is the Catch!Alice sends her ID in message 5Alice’s ID encrypted with KTo find K Bob must know KABTo get KAB Bob must know he’s talking to Alice!Result: Alice’s ID must be IP address!Useless mode for the “road warrior”Why go to all of the trouble of trying to hide identities in 6message protocol? || Unit 5 - 118```",
        "```\fIKE Phase 1: Symmetric Key (Aggressive Mode)IC, “Alice”, ga mod p, RA, CPIC,RC, “Bob”, RB,gb mod p, CS, proofBAliceIC,RC, proofABobSame format as digital signature aggressive modeNot trying to hide identities…As a result, does not have problems of main modeBut does not (pretend to) hide identities || Unit 5 - 119```",
        "```\fIKE Phase 1: Public Key Encryption (Main Mode)IC, CPIC,RC, CSIC,RC, ga mod p, {RA}Bob, {“Alice”}BobIC,RC, gb mod p, {RB}Alice, {“Bob”}AliceAliceIC,RC, E(proofA, K)IC,RC, E(proofB, K)BobCP = crypto proposed, CS = crypto selectedIC = initiator “cookie”, RC = responder “cookie”K = h(IC,RC,gab mod p,RA,RB)SKEYID = h(RA, RB, gab mod p)proofA = h(SKEYID,ga,gb,IC,RC,CP,“Alice”) || Unit 5 - 120```",
        "```\fIKE Phase 1: Public Key Encryption(Aggressive Mode)IC, CP, ga mod p,{“Alice”}Bob, {RA}BobIC,RC, CS, gb mod p,{“Bob”}Alice, {RB}Alice, proofBAliceIC,RC, proofABobK, proofA, proofB computed as in main modeNote that identities are hiddenThe only aggressive mode to hide identitiesThen why have main mode? || Unit 5 - 121```",
        "```\fPublic Key Encryption Issue?Public key encryption, aggressive modeSuppose Trudy generatesExponents a and bNonces RA and RBTrudy can compute “valid” keys and proofs: gab mod p, K,SKEYID, proofA and proofBAlso true of main mode || Unit 5 - 122```",
        "```\fPublic Key Encryption Issue?IC, CP, ga mod p,{“Alice”}Bob, {RA}BobIC,RC, CS, gb mod p,{“Bob”}Alice, {RB}Alice, proofBTrudyas AliceIC,RC, proofATrudyas BobTrudy can create exchange that appears to be between Aliceand BobAppears valid to any observer, including Alice and Bob! || Unit 5 - 123```",
        "```\fPlausible DeniabilityTrudy can create “conversation” that appears to be betweenAlice and BobAppears valid, even to Alice and Bob!A security failure?In this mode of IPSec, it is a featurePlausible deniability: Alice and Bob can deny that anyconversation took place!In some cases it might be a security failureIf Alice makes a purchase from Bob, she could laterrepudiate it (unless she had signed) || Unit 5 - 124```",
        "```\fIKE Phase 1 CookiesCookies (or “anti-clogging tokens”)provide a weak form of source address identification for both partiessupposed to make denial of service more difficultNo relation to Web cookiesTo reduce DoS, Bob wants to remain stateless as long as possibleBut Bob must remember CP from message 1 (required for proof ofidentity in message 6)Bob must keep state from 1st message on!These cookies offer little DoS protection! || Unit 5 - 125```",
        "```\fIKE Phase 1 SummaryResult of IKE phase 1 isMutual authenticationShared symmetric keyIKE Security Association (SA)But phase 1 is expensive (in public key and/or main mode cases)Developers of IKE thought it would be used for lots of things ⎯ notjust IPSecPartly explains over-engineering… || Unit 5 - 126```",
        "```\fIKE Phase 2Phase 1 establishes IKE SAPhase 2 establishes IPSec SAComparison to SSLSSL session is comparable to IKE Phase 1SSL connections are like IKE Phase 2IKE could be used for lots of thingsBut in practice, it’s not! || Unit 5 - 127```",
        "```\fIKE Phase 2IC,RC,CP,E(hash1,SA,RA,K)IC,RC,CS,E(hash2,SA,RB,K)AliceIC,RC,E(hash3,K)BobKey K, IC, RC and SA known from Phase 1Proposal CP includes ESP and/or AHHashes 1,2,3 depend on SKEYID, SA, RA and RBKeys derived from h(SKEYID,RA,RB,junk), junk is publicRecall SKEYID depends on phase 1 key methodOptional PFS (ephemeral Diffie-Hellman exchange) || Unit 5 - 128```",
        "```\fIPSecAfter IKE Phase 1, we have an IKE SAAfter IKE Phase 2, we have an IPSec SABoth sides have a shared symmetric keyNow what?We want to protect IP datagramsBut what is an IP datagram?From the perspective of IPSec… || Unit 5 - 129```",
        "```\fIP ReviewIP datagram is of the formIP headerdataWhere IP header is || Unit 5 - 130```",
        "```\fIP and TCPConsider HTTP traffic (over TCP)IP encapsulates TCPTCP encapsulates HTTPIP headerdataIP headerTCP hdrHTTP hdrapp dataIP data includes TCP header, etc.  || Unit 5 - 131```",
        "```\fIPSec Transport ModeIPSec Transport ModeIP header dataIP header ESP/AHdataTransport mode designed for host-to-hostTransport mode is efficientAdds minimal amount of extra headerThe original header remains intactPassive attacker can see who is talking || Unit 5 - 132```",
        "```\fIPSec: Host-to-HostIPSec transport modeNote that there may be firewalls in between ⎯ is that a problem? || Unit 5 - 133```",
        "```\fIPSec Tunnel ModeIPSec Tunnel ModeIP header datanew IP hdrESP/AHIP header dataTunnel mode for firewall to firewall trafficOriginal IP packet encapsulated in IPSecOriginal IP header not visible to attackerNew header from firewall to firewallAttacker does not know which hosts are talking || Unit 5 - 134```",
        "```\fIPSec: Firewall-to-FirewallIPSec tunnel modeLocal networks unprotectedSo, is there any advantage here? || Unit 5 - 135```",
        "```\fComparison of IPSec ModesTransport ModeHost-to-hostTransport ModeIP header dataIP header ESP/AHTunnel ModeFirewall-to-firewalldataTunnel ModeIP header datanew IP hdrESP/AHTransport mode notnecessaryTransport mode moreefficientIP header data || Unit 5 - 136```",
        "```\fTransport Mode and Tunnel ModeIndependent of whether ESP or AH is used, IPSec can use eithertransport mode ortunnel mode. In transport mode the new ESP/AH header is sandwiched betweenthe IP header and the data. In tunnel mode the entire IP packet is encapsulated in a new IPpacket.  || Unit 5 - 137```",
        "```\fAH vs ESPAH: Authentication HeaderIntegrity only (no confidentiality)Integrity-protect everything beyond IP header and somefields of header (why not all fields?)ESP: Encapsulating Security PayloadIntegrity and confidentiality both requiredProtects everything beyond IP headerIntegrity only by using NULL encryption || Unit 5 - 138```",
        "```\fESP’s NULL EncryptionAccording to RFC 2410NULL encryption “is a block cipher the origins of which appear tobe lost in antiquity”“Despite rumors”, there is no evidence that NSA “suppressedpublication of this algorithm”Evidence suggests it was developed in Roman times asexportable version of Caesar’s cipherCan make use of keys of varying lengthNo IV is requiredNull(P,K) = P for any P and any key KSecurity people have a strange sense of humor! || Unit 5 - 139```",
        "```\fWhy Does AH Exist? (1)Cannot encrypt IP headerRouters must look at the IP headerIP addresses, TTL, etc. IP header exists to route packets!AH protects immutable fields in IP headerCannot integrity protect all header fieldsTTL, for example, must changeESP does not protect IP header at all || Unit 5 - 140```",
        "```\fWhy Does AH Exist? (2)ESP encrypts everything beyond the IP header (if non-nullencryption)If ESP encrypted, firewall cannot look at TCP header (e. g. , portnumbers)Why not use ESP with null encryption?Firewall sees ESP header, but does not know whether nullencryption is used || Unit 5 - 141```",
        "```\fWhy Does AH Exist? (3)The real reason why AH existsAt one IETF meeting “someone from Microsoft gave an impassionedspeech about how AH was useless…”“…everyone in the room looked around and said `Hmm.  He’s right, andwe hate AH also, but if it annoys Microsoft let’s leave it in since we hateMicrosoft more than we hate AH. ” || Unit 5 - 142```",
        "```\fIPSec SecurityWhat kind of protection?Confidentiality?Integrity?Both?What to protect?Data?Header?Both?ESP/AH do some combinations of these || Unit 5 - 143```",
        "```\f5. 6 802. 11 Wireless LAN Security || Unit 5 - 144```",
        "```\f802. 11 Wireless LAN SecurityWireless traffic can be monitored by any radio in range, and need not bephysically connected. The original 802. 11 specification had security featuresWired Equivalent Privacy (WEP) algorithmbut found this contained major weaknesses802. 11i task group developed capabilities to address WLAN security issuesWi-Fi Alliance Wi-Fi Protected Access (WPA)Final 802. 11i Robust Security Network (RSN) || Unit 5 - 145```",
        "```\f802. 11i RSN - GoalsReplace WEP by protocol that properly uses encryptionAdd data authenticity and integrityAdd proper authenticationManufacture “fresh” keys for every sessionTie keys to the authentication || Unit 5 - 146```",
        "```\f802. 11i RSN Services and ProtocolsMAC-level data areencrypted, along with amessage integrity codethat ensures that the datahave not been alteredServicesRobust Security Network (RSN)AccessControlAuthentication andKey generationProtocolEnforces the use of theauthentication function,routes the messagesproperly, and facilitates keyexchangeIEEE 802. 1xPort-basedaccesscontrolExtensibleAuthenticationProtocol (EAP)A protocol is used to define anexchange between a user and anAS that provides mutualauthentication and generatestemporary keysConfidentiality andIntegrityTKIPCCMPTKIP = Temporal Key Integrity ProtocolCCMP = Counter Mode with CBCMAC Protocol || Unit 5 - 147```",
        "```\f802. 11i RSN Cryptographic AlgorithmsAlgorithmServicesRobust Security Network (RSN)ConfidentialityTKIP(RC4)CCMP(AES)Integrity and AuthenticationHMACSHA-1HMACMD5TKIP(MichaelMIC)CCM(AES CBCMAC)KeyGenerationHMACSHA-1 || Unit 5 - 148```",
        "```\f802. 11i Phases of Operation1. 2. 3. 4. 5. IEEE 802. 11i RSN can be broken down into five distinct phases of:Discovery: an STA and an AP are involved in this phase. An STA and an AP recognize each otherAgree on set of security capabilitiesEstablish an association for future communication using these securitycapabilitiesAuthentication: an STA, an AP and the AS are involved in this phase. An STA and AS mutually authenticate each otherKey Management: an STA, an AP and the AS are involved in this phase as well. Cryptographic keys will be generated by the AS to be moved to AP and thenpushed to the STA. Protected data transfer: Frames are exchanged between the STA and the other STA(end station) through the AP.  security is not provided end-to-end. Connection termination: The AP and STA exchange frames to turn down the secureconnection.  || Unit 5 - 149```",
        "```\f802. 11i Phases of OperationSecuritycapabilitiesdiscoverySTA <-> ASmutualauthentication802. 1X keymanagementRADIUS-basedkey distributionSTA <-> APencryptedchannel.  Notend-to-endprotection || Unit 5 - 150```",
        "```\fDigging deeper - Discovery phaseAn STA and an AP recognize each other and agree on a set of security capabilities tobe used after the association. These security capabilities include:Confidentiality and integrity protocols for protecting unicast traffic (only betweenSTA and AP.  Only AP specifies the protecting multicast traffic),Authentication method,Cryptography key management approach. The specification of a protocol, along with the chosen key length (if variable) is knownas a cipher suite. The options for the confidentiality and integrity cipher suite are:WEP, (for backward compatibility), TKIP, CCMP, vendor-specific methods. The options for the authentication and key management (AKM) suite are:IEEE 802. 1X, pre-shared key PSK, vendor-specific methods).  || Unit 5 - 151```",
        "```\fDigging deeper - Discovery phaseProbe RequestProbe Response + RSN IE (AP supports CCMPMcast, CCMP Ucast, 802. 1X Auth)STA802. 11 Open System AuthAP802. 11 Open Auth (success)Association Req + RSN IE (STA requestsCCMP Mcast, CCMP Ucast, 802. 1X Auth)Association Response (success)Three MPDU (frame) exchanges:1.  Network and security capability discovery, through passive or active scanning.  APadvertises its RSN Information Element (RSN IE)2.  Open system authentication to maintain a backward computability with legacy 802. 11devices (STA or AP) to perform simple exchange identities. 3.  Association, to agree and confirm the chosen cipher suites between STA and AP || Unit 5 - 152```",
        "```\fDiscovery phase – SummaryAt the end of discoverySTA knowsThe alleged SSID (AP) of the networkThe alleged authentication and cipher suites of the networkThe AP knows which of its authentication and cipher suites the STAallegedly choseA STA and an AP have established an 802. 11 channelThe associated STA and AP are ready to authenticate || Unit 5 - 153```",
        "```\fDigging deeper - Authentication phaseGoalsEstablish a mutually authenticated session between STA and ASEstablish a session key shared by AS and STASession  key is freshMutually authenticated  bound only to AS and STATied back to authorization decisionDefend against eavesdropping, man-in-the-middle attacks, forgeries,replay, dictionary attacks against either party. Identity protection not a goalCan’t hide the MAC address || Unit 5 - 154```",
        "```\fDigging deeper - Authentication phaseIEEE 802. 11i makes use of another standard that was designed to provide accesscontrol functions for LANs. The standard is IEEE 802. 1X, Port-Based Network Access Control. Defined in IEEE STD 802. 1X-2001Runs over all 802 LANsAllow/deny port filtering rulesMany parts of how 802. 1x works are within other standards such asEAP (Extensible Authentication Protocol) , more later,and RADIUS (Remote Authentication Dial-In User Service) . The 802. 1x standard is just a mechanism that denies all traffic except EAP packetsfrom accessing the networkRADIUS protocol is used to create an encrypted tunnel between the AP and the AS(aka RADIUS server), more later. IEEE 802. 1X uses the terms supplicant, authenticator, that are correspond to thewireless station and the AP.  || Unit 5 - 155```",
        "```\fDigging deeper - Authentication phaseSTAAPSTA 802. 1X blocks port fordata trafficASAP 802. 1X blocks port for datatrafficthe AP controlledport is still blockedto data traffic802. 1X/EAP-Request Identity802. 1X/EAP-Response Identity(EAP type specific)RADIUS Access Request/IdentityEAP type specific mutual authenticationDerive Pairwise Master Key (PMK)Derive Pairwise Master Key (PMK)RADIUS Accept (with PMK)802. 1X/EAP-SUCCESS802. 1XRADIUS || Unit 5 - 156```",
        "```\fDigging deeper – (EAP)Extensive Authentication Protocol (EAP) is an authentication framework (defined inRFC 3748 )EAP provides a transport for keying material and parameters generated by EAPmethods. EAP relies on “concrete” methods plugged into it for authenticationE. g. , EAP-TLS, EAP-TTLS, EAP-MD5, etc. EAP only defines message formats.  Each protocol that uses EAP defines a wayto encapsulate EAP messages within that protocol's messages. E. g. , the encapsulation of EAP over IEEE 802 is defined in IEEE 802. 1X andknown as \"EAP over LANs\" or EAPOLRADIUS protocols can also encapsulate EAP messages.  They are often used byNetwork Access Server (NAS) devices to forward EAP packets between AccessPoint and these Authentication Servers. EAP frame is made up of five main fields: code, identifier, length, type, and data. (see next slide) || Unit 5 - 157```",
        "```\fDigging deeper – (EAP)1 → EAP Request2 → EAP Response3 → Success Indicator4 → Failure IndicatorTo match responseswith requests.  Mustbe changed on eachRequest packet. Identifies the structureof an EAP packet. E. g. , 13 → EAP-TLSEAP messageCodeIdentifier1 Byte1 ByteThe length of theEAP packetLength2 BytesType1 ByteDataVariable LengthHere, a user would providethe authentication portion || Unit 5 - 158```",
        "```\fDigging deeper – RADIUSThe RADIUS protocol specifications are currently defined in RFC 2865 andRFC 2866. RADIUS is a client/server protocol that runs in the application layer,using UDP as transport. The protocol works by creating an encrypted tunnel between the networkdevice and the RADIUS server. This tunnel is used for sending all the Authentication AuthorizationAccounting (AAA) information. To start this encrypted tunnel, a phrase or password called the sharedsecret between the AP and AS is needed. Once the shared secret is correctly set up, secure communication cantake place.  || Unit 5 - 159```",
        "```\fDigging deeper – RADIUS1 → Access-Request. 2 → Access-Accept3 → Access-Reject4 → Access-ChallengeRADIUS packet formatsCodeIdentifier1 Byte1 ByteLength2 BytesAuthenticator16 ByteRADIUS has only four types of packets for authentication and there are other packettypes for accounting.  However, we only focus on the authentication packets. 1.  Access-Request.  This packet allows the RADIUS sequence to take place. 2.  Access-Accept.  This packet informs the RADIUS client that the authenticationprovided to it was correct. 3.  Access-Reject.  This packet informs the RADIUS client that the authenticationprovided to it was incorrect. 4.  Access-Challenge.  This packet is used to challenge a RADIUS client for itsauthentication credentials.  || Unit 5 - 160```",
        "```\fDigging deeper – EAP-TLSEAP-TLS is not part of 802. 11i; neither is any other specific authenticationmethodBut EAP-TLS is the de facto 802. 11i authentication methodCan meet all 802. 11i requirementsOther widely deployed methods do notEAP-TLS = TLS Handshake over EAPEAP-TLS defined by RFC 2716TLS defined by RFC 2246Always requires provisioning AS certificate on the STAMutual authentication requires provisioning STA certificates || Unit 5 - 161```",
        "```\fDigging deeper – EAP-TLSRemember, EAP frame is made up of five main fields: code, identifier, length, type,and data. Always 13EAP messageCodeIdentifier1 Byte1 ByteLengthType2 BytesFlags1 ByteTLS Message Length1 ByteL = Length includedM = More fragmentsS = EAP-TLS start*R = ReservedM S4 BytesR RDataVariable LengthTLS Data .  .  . Variable LengthR R* The start bit is exist only when Code =1 (EAP request).  For all other codes it is R || Unit 5 - 162```",
        "```\fExample –EAP-TLS (1)STAAPAP-RADIUS KeyAS802. 1X/EAP-Request Identity802. 1X/EAP-Response IdentityRADIUS_Access_Request/EAPResponse Identity802. 1X/EAP-requestEAP type = TLSTLS start bit setRADIUS_access_challengeEAP type = TLS802. 1X/EAP-responseEAP type = TLSTLS client_helloRADIUS_Access_Request/EAPResponse EAP type = TLSTLS client_hello802. 1X/EAP-responseEAP type = TLSTLS server_hello, TLScertificate, TLS server keyexchange, TLS certificaterequest, TLS server_hello_doneRADIUS_access_challengeEAP type = TLSClient’s TLSversion, sessionId,random no, ciphersuites supported. TLS version,sessionId,anotherrandom no,cipher suitesMasterKey = TLS-PRF(PreMasterKey, “master secret” || random1 || random2) || Unit 5 - 163```",
        "```\fExample – EAP-TLS (2)STAAP802. 1X/EAP responseEAP type = TLSTLS certificate, TLS client key exchange,TLS certificate verify, TLS change cipherspec, TLS finished802. 1X/EAP responseEAP type = TLSTLS change_cipher_spec, TLS finished802. 1X/EAP responseEAP type = TLSAP-RADIUS KeyASRADIUS Access Request/EAPResponse EAP type = TLSRADIUS access challengeEAP type = TLSRADIUS Access Request/EAPResponse EAP type = TLSPMK = TLS-PRF(MasterKey, “client EAP encryption” || random1 || random2)802. 1X/EAP SuccessRADIUS Access AcceptEAP type = TLS, PMK || Unit 5 - 164```",
        "```\fAuthentication SummaryAt the end of authentication phaseThe AS and STA have established a session if concrete EAP methoddoesThe AS and STA possess a mutually authenticated Master Key ifconcrete EAP method doesMaster Key represents decision to grant access based onauthenticationSTA and AS have derived PMKPMK is an authorization token to enforce access control decisionAS has distributed PMK to an AP (hopefully, to the STA’s AP) || Unit 5 - 165```",
        "```\f802. 1X Key Management802. 11i data protocols fail without “fresh” keysWant to use 802. 1X frameworkOriginal 802. 1X key management hopelessly broken, so redesigned by802. 11iNew model:Derive a Pairwise Master Key (PMK)AP and STA use PMK to derive Pairwise Transient Key (PTK)Use PTK to protect the link || Unit 5 - 166```",
        "```\fPairwise Key HierarchyA pre-shared key (PSK) is a secret key shared by the AP and a STAORMasterKey = TLS-PRF(PreMasterKey, “master secret” || random1 || random2)PMK = TLS-PRF(MasterKey, “client EAP encryption” || random1 || random2)Pairwise Transient Key (PTK) = EAPoL-PRF(PMK, AP Nonce || STA Nonce|| AP MACAddr || STA MAC Addr)Key Confirmation Key(KCK) – PTK bits 0–127Key Encryption Key (KEK) –PTK bits 128–255Temporal Key – PTK bits 256–n128 bits (CCMP) , 256 bits (TKIP) || Unit 5 - 167```",
        "```\fKey Management OverviewSTAAPASStep 1: Use RADIUS to push PMK from AS to APStep 2: Use PMK and 4-Way Handshake toderive, bind, and verify PTKStep 3: Use Group Key Handshake to send GTKfrom AP to STA || Unit 5 - 168```",
        "```\fStep 2: 4-Way HandshakeSTAAPPMKPMKPick Random ANonceEAPoL-Key(Reply Required, Unicast, ANonce)Pick Random SNonce, Derive PTK = EAPoL-PRF(PMK,ANonce | SNonce | AP MAC Addr | STA MAC Addr)EAPoL-Key(Unicast, SNonce, MIC, STA RSN IE)Derive PTKEAPoL-Key(Reply Required, Install PTK, Unicast,ANonce, MIC, AP RSN IE)EAPoL-Key(Unicast, MIC)Install TKused to secure data trafficInstall TK || Unit 5 - 169```",
        "```\fStep3: Group Key HandshakeSTAAPPTKPTKPick Random GNonce, Pick Random GTKEncrypt GTK with KEKEAPoL-Key(GNonce, MIC, GTK)Decrypt GTKEAPoL-Key(Group ACK, MIC)unblocked data trafficunblocked data traffic || Unit 5 - 170```",
        "```\fWhat is EAPoL?Extensive Authentication Protocol over Local Area Network (EAPOL) is partof EAP, but it is outlined inside the 802. 1x standard. This is because the 802. 1x standard allows certain EAP message typesto pass through an AP to the STA. This traffic (the EAP message ) is outlined with five frame types. This means that only these five frame types are allowed to passthrough an AP to a STA.  || Unit 5 - 171```",
        "```\fWhat is EAPoL?EAPOL frame formatPAEEthertypeProtocolversionPackettypePacketBody length2 Bytes1 Byte1 Byte2 Bytes= 0x88E8for EAPoL1. 2. 3. 4. 5. EAP-PacketEAPOL-StartEAPOL-LogoffEAPOL-KeyEAPOL-ASF-Alert0000 00000000 00010000 00100000 00110000 0100PacketbodyDescriptorType1 ByteDescriptorBodyVariable LengthEAPOL-Packet: used to identify the packet as an EAP packet. EAPOL-Start: used to begin an EAP conversation or an 802. 1x authentication. EAPOL-Logoff: used to end an EAP conversation or an 802. 1x authentication. EAPOL-Key: used to exchange keying information between the AP and the STA. EAPOL-Encapsulated-ASF-Alert: used to carry SNMP trap information out a non-802. 1xauthenticated port.  || Unit 5 - 172```",
        "```\fOne Last DetailIEEE 802. 11i uses a pseudorandom function (PRF) in many places. For example, it is used to generate nonces, to expand pairwise keys, and togenerate the GTK. The PRF is built on the use of HMAC-SHA-1. Recall that HMAC-SHA-1 takes a message (block of data)and a key of length at least 160 bits and produces a 160-bithash value. The IEEE 802. 11i PRF takes four parameters(a secret key K, an application specific text string A,some data specific to each case B, and the desirednumber of pseudorandom bits Len) as input,and produces the desired number of random bits. HMAC algorithm is run once, producing a 160-bit hash value. If more bits are required, HMAC is run again with the sameinputs, except that i is incremented each time,until the necessary number of bits is generated.  || Unit 5 - 173```",
        "```\fKey Management Summary4-Way HandshakeEstablishes a fresh pairwise key bound to STA and AP for this sessionProves liveness of peersDemonstrates there is no man-in-the-middle between PTK holders ifthere was no man-in-the-middle holding the PMKGroup Key Handshake provisions group key to all STAs || Unit 5 - 174```",
        "```\f802. 11i Protected Data Transfer PhaseIEEE 802. 11i defines two schemes for protecting 802. 11 MPDU datamessage integrity and confidentiality:the Temporal Key Integrity Protocol (TKIP), andthe Counter Mode-CBC MAC Protocol (CCMP). Temporal Key Integrity Protocol (TKIP)TKIP is designed to require only software changes to devices that areimplemented with the older wireless LAN security approach (i. e. , WEP). TKIP adds a 64-bit message integrity code (MIC),generated by an algorithm, called Michael, to the 802. 11 MACframe after the data field. TKIP provides data confidentiality by encrypting the MPDU plus MICvalue using RC4.  || Unit 5 - 175```",
        "```\f802. 11i Protected Data Transfer PhaseCounter Mode-CBC MAC Protocol (CCMP)Intended for newer IEEE 802. 11 devices that are equipped with thehardware to support this schemeUses the cipher block chaining message authentication code (CBC-MAC)with AES for integrityUses the CRT block cipher mode with AES for encryptionThe scheme uses a 48-bit packet number to construct a nonce toprevent replay attacks. Authenticated Encryption combining Counter mode (CTR) and CBCMAC, using a single keyAssumes 128 bit block cipher – IEEE 802. 11i uses AES || Unit 5 - 176```",
        "```\fCCM Mode OverviewUse CBC-MAC to compute a MIC on the plaintext header, length of theplaintext header, and the payloadUse CTR mode to encrypt the payloadCounter values 1, 2, 3, …Use CTR mode to encrypt the MICCounter value 0EncryptedHeaderPayloadMICAuthenticated || Unit 5 - 177```",
        "```\fCCM PropertiesCTR + CBC-MAC (CCM) based on a block cipherCCM provides integrity and confidentialityA CBC-MAC of the plaintext is appended to the plaintext to form anencoded plaintextThe encoded plaintext is encrypted in CTR modeCCM is packet orientedCCM can leave any number of initial blocks of the plaintextunencrypted || Unit 5 - 178```",
        "```\fData Transfer SummaryWEPTKIPCCMPCipherRC4RC4AESKey Size40 or 104 bits128 bits128 bits encryption,64 bit authKey Life24-bit IV, wrap48-bit IV48-bit IVPacket KeyConcat. Mixing FncNot NeededIntegrity (data)CRC-32MichaelCCMIntegrity (Header)NoneMichaelCCMReplayNoneUse IVUse IVKey Mgmt. NoneEAP-basedEAP-based || Unit 5 - 179```",
        "```\f802. 11i RSN - KeysAbbreviatiNameonPSKPre-Shared KeyDescription / PurposeBecomes the PMK in pre-shared key environments. PMKPair-wise Master KeyUsed with other inputs to derive the PTK. GMKGroup MasterKeyUsed with other inputs to derive the GTK. PTKPair-wise Transient KeyDerived from the PMK.  Comprises the EAPOL-KCK, EAPOL-KEK,and TK and (for TKIP) the MIC key. TKTemporal KeyUsed with TKIP or CCMP to provide confidentiality and integrityprotection for unicast user traffic. GTKGroupTemporal KeyMIC KeyEAPOL-KCKEAPOL-KEKWEP KeyDerived from the GMK.  Used to provide confidentiality andintegrity protection for multicast/broadcast user traffic. Message Integrity Code Used by TKIP’s Michael MIC to provide integrity protection ofKeymessages. EAPOL-Key Confirmation Used to provide integrity protection for key material distributedKeyduring the 4-Way Handshake. EAPOL-Key EncryptionKeyWired EquivalentPrivacyKeyUsed to ensure the confidentiality of the GTK and other keymaterial in the 4-Way Handshake. Used with WEP.  || Unit 5 - 180```",
        "```\f802. 11i Phases of Operation || Unit 5 - 181```",
        "```\f802. 11i RSN Cryptographic AlgorithmsAlgorithmServicesRobust Security Network (RSN)ConfidentialityTKIP(RC4)CCMP(AES)Integrity and AuthenticationHMACSHA-1HMACMD5TKIP(MichaelMIC)CCM(AES CBCMAC)KeyGenerationHMACSHA-1 || Unit 5 - 182```",
        "```\f802. 11i RSN Services and ProtocolsServicesAccessControlAuthentication andKey generationProtocolRobust Security Network (RSN)IEEE 802. 1xPort-basedaccesscontrolExtensibleAuthenticationProtocol (EAP)Confidentiality andIntegrityTKIPCCMP || Unit 5 - 183```"
    ]
}