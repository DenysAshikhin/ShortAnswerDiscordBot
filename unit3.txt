Unit 3
Software-Defined Networking
(SDN)

Unit 3 - 2

Unit 3: Software-Defined Networking
3.1 The limitations of the traditional network architectures.
3.2 The key requirements for an SDN architecture.

3.3 The functions of the SDN data plane.
3.4 The OpenFlow logical architecture and network protocol.

3.5 The functions of the SDN control plane.
3.6 An overview of OpenDaylight and REST APIs.
3.7 An overview of the SDN application plane architecture.
Reading: https://www.opennetworking.org/sdn-definition/

Unit 3 - 3

3.1 The limitations of the traditional network
architectures

Unit 3 - 4

Evolving Network Requirements
A number of trends are driving network providers and users to
reevaluate traditional approaches to network architecture.
These trends can be grouped under the categories of
demand,

Due to the increase in Cloud Computing, Big Data, Mobile traffic,
IoT, etc.
supply,

Due to the increase in the capacity of the network transmission
technologies (e.g., Ethernet, WiFi, 5G)
traffic patterns.

Unit 3 - 5

So …
Traditional Network Architectures are
Inadequate!
Why?

Unit 3 - 6

Traditional Network Architectures are Inadequate
The traditional internetworking approach is based on the TCP/IP
protocol architecture.
Three significant characteristics of this approach are as follows:
Two-level end system addressing

Routing based on destination
Distributed autonomous control

Unit 3 - 7

Limitations
The Open Networking Foundation (ONF) cites four general
limitations of traditional network architectures:
Static, complex architecture
Inconsistent policies

Inability to scale
Vendor dependence

Unit 3 - 8

3.2 The key requirements for an SDN
architecture

Unit 3 - 9

The principal requirements for a modern networking

Adaptability

Networks must adjust and respond dynamically, based on
application needs, business policy, and network conditions.

Automation

Policy changes must be automatically propagated so that
manual work and errors can be reduced.

Maintainability

Introduction of new features and capabilities (software upgrades,
patches) must be seamless with minimal disruption of operations.

Model management

Network management software must allow management of the
network at a model level, rather than implementing conceptual
changes by reconfiguring individual network elements.

Mobility

Control functionality must accommodate mobility, including mobile
user devices and virtual servers.

Integrated security

Network applications must integrate seamless security as a core
service instead of as an add-on solution.

On-demand scaling

Implementations must have the ability to scale up or scale down
the network and its services to support on-demand requests.

Unit 3 - 10

SDN and NFV
To provide adaptability and scalability, two key technologies that are
rapidly being deployed by a variety of network service and
application providers are:
software-defined networking (SDN)
Discussed in the subsequent slides
network functions virtualization (NFV)
Will be covered in SE4455

Unit 3 - 11

Software-defined networking (SDN)
SDN is replacing the traditional networking model, it provides an
enhanced level of flexibility to meet the needs of newer networking
and IT trends such as cloud, mobility, social networking, and video.
In SDN, there are two elements involved in forwarding packets
through routers
a control function, which
decides the route for the flow to
take and the relative priority
of traffic,

and a data function, which
forwards data based on
control-function policy.

Unit 3 - 12

The traditional network Vs. the SDN approaches

Unit 3 - 13

The SDN approach

Unit 3 - 14

The SDN approach - The data plane
The data plane consists of physical switches and virtual switches,
which are responsible for forwarding packets.
The internal implementation of buffers, priority parameters, and
other data structures should be uniform and open to the SDN
controllers.
This can be defined in terms of an open application programming
interface (API) between the control plane and the data plane
(southbound API).

The most prominent example of such an open API is OpenFlow.

Unit 3 - 15

The SDN approach - The control plane
SDN controllers can be implemented directly on a server or on a
virtual server.
OpenFlow or some other open API is used to control the switches in
the data plane.
In addition, controllers use information about capacity and demand
obtained from the networking equipment through which the traffic
flows.
SDN controllers also expose northbound APIs, which allow
developers and network managers to deploy a wide range of offthe-shelf and custom-built network applications.
A number of vendors offer a Representational State Transfer
(REST)-based API to provide a programmable interface to their SDN
controller.
Unit 3 - 16

The SDN approach - The application plane
At the application plane are a variety of applications that interact
with SDN controllers.
SDN applications are programs that may use an abstract view of the
network for their decision-making goals.
These applications convey their network requirements and desired
network behavior to the SDN controller via a northbound API.
Examples of applications are
energy-efficient networking,

security monitoring,
access control, and
network management.

Unit 3 - 17

Characteristics of SDN
The control plane is separated from the data plane; data plane
devices become simple packet-forwarding devices.
The control plane is implemented in a centralized controller or set of
coordinated centralized controllers.
The SDN controller has a centralized view of the network or
networks under its control.
The controller is portable software that can run on servers and is
capable of programming the forwarding devices based on a
centralized view of the network.

The network is programmable by applications running on top of the
SDN controllers; the SDN controllers present an abstract view of
network resources to the applications.

Unit 3 - 18

Standards-Developing Organizations
Unlike some technology areas, such as Wi-Fi, there is no single
standards body responsible for developing open standards for SDN
and NFV.
Rather, there is a large and evolving collection of standardsdeveloping organizations (SDOs), industrial consortia, and open
development initiatives involved in creating standards and guidelines
for SDN and NFV.
The following table lists the main SDOs and other organizations
involved in the effort and the main outcomes so far produced.

Unit 3 - 19

SDN and NFV
Standards
Activities

Unit 3 - 20

OpenDaylight
An open source software activity under the auspices of the Linux
foundation
Its member companies provide resources to develop an SDN
controller for a wide range of applications
Is more in the nature of an open development initiative than a
consortium
Also supports network programmability via southbound protocols, a
bunch of programmable network services, a collection of
northbound APIs, and a set of applications

Unit 3 - 21

OpenStack
Is an open source software project that aims to produce an open
source cloud operating system
Provides multitenant Infrastructure as a Service (IaaS) and aims to
meet the needs of public and private clouds regardless of size, by
being simple to implement and massively scalable
SDN technology is expected to contribute to its networking part,
and to make the cloud operating system more efficient, flexible, and
reliable

Unit 3 - 22

3.3 The functions of the SDN data plane

Unit 3 - 23

The SDN data plane
Referred to as the resource layer or as the infrastructure layer,
where network forwarding devices perform the transport and
processing of data according to
decisions made by the SDN
control plane.

The important characteristic of
the network devices in an SDN
network is that these devices
perform a simple forwarding
function, without embedded
software to make autonomous
decisions.
The data plane network devices
also called data plane network
elements or switches.
Unit 3 - 24

A simple forwarding function

Unit 3 - 25

A simple forwarding function
The principal functions of the network device are the following:
Control support function: Interacts with the SDN control layer to
support programmability via resource-control interfaces. The switch
communicates with the controller and the controller manages the switch
via the OpenFlow switch protocol.

Data forwarding function: Accepts incoming data flows from other
network devices and forwards them along the data forwarding paths
that have been computed and established by the SDN controller
according to the rules defined by the SDN applications.

The network device can alter the packet header before forwarding,
or discard the packet. As shown, arriving packets may be placed in
an input queue, awaiting processing by the network device, and
forwarded packets are generally placed in an output queue,
awaiting transmission.
Unit 3 - 26

3.4 The OpenFlow logical architecture and
network protocol

Unit 3 - 27

The OpenFlow
There must be a
common logical
architecture in all
network devices to be
managed by an SDN
controller. The SDN
controller should see a
uniform logical switch
functionality

A standard, secure
protocol is needed
between the SDN
controller and the
network device.

Unit 3 - 28

The OpenFlow
OpenFlow is both a protocol between SDN controllers and network
devices and a specification of the logical structure of the network
switch functionality.

Unit 3 - 29

The OpenFlow
OpenFlow is defined in the OpenFlow Switch Specification, published
by the Open Networking Foundation (ONF).
An SDN controller communicates with OpenFlow-compatible
switches using the OpenFlow protocol running over Transport
Layer Security (TLS).
Each switch connects to other OpenFlow switches and, possibly, to
end-user devices that are the sources and destinations of packet
flows.

On the switch side, the interface is known as an OpenFlow
channel. These connections are via OpenFlow ports.
An OpenFlow port also connects the switch to the SDN controller.

Unit 3 - 30

The OpenFlow – Switch ports
OpenFlow defines three types of ports:
Physical port: Corresponds to a hardware interface of the switch. For
example, an Ethernet switch.
Logical port: Does not correspond directly to a hardware interface of
the switch. May be defined in the switch using non-OpenFlow methods
(for example, link aggregation groups, tunnels, loopback interfaces) and
may map to various physical ports.

Reserved port: It specifies generic forwarding actions such as sending
to and receiving from the controller, flooding, or forwarding using nonOpenFlow methods, such as “normal” switch processing.

Unit 3 - 31

The OpenFlow – Tables
The OpenFlow defines three types of tables:
A flow table: matches incoming packets to a particular flow and
specifies what functions are to be performed on the packets. There may
be multiple flow tables that operate in a pipeline fashion, as explained
subsequently.

A Group table: a flow table may direct a flow to a group table, which
may trigger a variety of actions that affect one or more flows.
A meter table: consists of meter entries that can trigger a variety of
performance-related actions on a flow.

Using the OpenFlow switch protocol, the controller can add, update,
and delete flow entries in tables, both reactively (in response to
packets) and proactively.

Unit 3 - 32

The flow table(s)
Each packet that enters an OpenFlow switch passes through one of more
flow tables. Each flow table consists of a number of rows, called entries,
consisting of seven components.

Unit 3 - 33

The flow table – Seven Components
Match fields

Used to select packets that match the values in the fields.

Priority

Relative priority of table entries. This is a 16-bit field with 0
corresponding to the lowest priority. In principle, there could be
216 = 64k priority levels.

Counters

Updated for matching packets. The OpenFlow specification defines
a variety of counters

Instructions

Instructions to be performed if a match occurs

Timeouts

Maximum amount of idle time before a flow is expired by the
switch.

Cookie

64-bit data value chosen by the controller. May be used by the
controller to filter flow statistics, flow modification and flow
deletion; not used when processing packets.

Flags

Flags alter the way flow entries are managed; for example, the
flag OFPFF_SEND_FLOW_REM triggers flow removed messages
for that flow entry.

Unit 3 - 34

The flow table – The match fields component
Ingress port

The identifier of the port on this switch on which the
packet arrived. This may be a physical port or a
switch-defined virtual port. Required in ingress tables.

Egress port

The identifier of the egress port from action set.
Required in egress tables.

Ethernet source and
destination addresses

Each entry can be an exact address, a bit masked
value for which only some of the address bits are
checked, or a wildcard value.

Ethernet type field

Indicates type of the Ethernet packet payload.

IP

Version 4 or 6.

IPv4 or IPv6 source address,
and destination address

Each entry can be an exact address, a bit masked
value, a subnet mask value, or a wildcard value.

TCP source and destination
ports

Exact match or wildcard value.

UDP source and destination
ports

Exact match or wildcard value

Unit 3 - 35

The flow table – The counters

Counter

Usage

Reference Count (active entries)

Per Flow Table

32

Duration (seconds)

Per Flow Entry

32

Received Packets

Per Port

64

Transmitted Packets

Per Port

64

Duration (seconds)

Per Port

32

Transmit Packets

Per Queue

64

Duration (seconds)

Per Queue

32

Duration (seconds)

Per Group

32

Duration (seconds)

Per Meter

32

Bit length

Unit 3 - 36

Packet flow through the processing pipeline
A switch includes one or more flow tables. If there is more than one
flow table, they are organized as a pipeline, with the tables labeled
with increasing numbers starting with zero.
The use of multiple tables in a pipeline, rather than a single flow
table, provides the SDN controller with considerable flexibility
The OpenFlow specification defines two stages of processing:
Ingress processing
Egress processing

Unit 3 - 37

Ingress processing always
happens, beginning with Table
0, and uses the identity of the
input port. Table 0 may be the
only table, in which case the
ingress processing is simplified
to the processing performed on
that single table, and there is
no egress processing.
Egress processing is the
processing that happens after
the determination of the output
port. It happens in the context
of the output port. This stage is
optional. If it occurs, it may
involve one or more tables.

Unit 3 - 38

The ingress processing
At the final table in the
pipeline forwarding to
another flow table is not
an option.
If and when a packet is
finally directed to an
output port, the
accumulated action set
is executed and then
the packet is queued for
output.

Unit 3 - 39

The egress processing
If egress processing is
associated with a
particular output port,
then after a packet is
directed to an output
port in the ingress
process, the packet is
directed to the first flow
table of the egress
pipeline
There is no group table
processing at the end of
the egress pipeline.

Unit 3 - 40

The use of multiple tables
The use of multiple tables enables the breaking down of a single flow into a
number of parallel subflows.

The use of multiple tables simplifies the processing in both the SDN controller and
the OpenFlow switch.

Actions such as next hop that apply to the aggregate flow can be defined once by the
controller and examined and performed once by the switch. The addition of new
subflows at any level involves less setup.
Therefore, the use of pipelined, multiple tables increases the efficiency of network
operations, provides granular control, and enables the network to respond to realtime changes at the application, user, and session levels.
Unit 3 - 41

The Group Tables
During the pipeline processing, a flow table may direct a flow of
packets to the group table rather than another flow table.
The group table and group actions enable OpenFlow to represent a
set of ports as a single entity for forwarding packets.
Different types of groups are provided to represent different
forwarding abstractions, such as multicasting and broadcasting.
Each group table consists of a number of rows, called group entries,
consisting of four components.

Unit 3 - 42

The Group Tables
Group identifier: A 32-bit unsigned integer uniquely identifying the
group. A group is defined as an entry in the group table.
Group type: Determines group semantics, explained in the next slide.
Counters: Updated when packets are processed by a group.

Action buckets: An ordered list of action buckets, where each action
bucket contains a set of actions to execute.

The action list is executed in sequence and generally ends with the
Output action, which forwards the packet to a specified port.
The action list may also end with the Group action, which sends the
packet to another group.

Unit 3 - 43

The Group Tables – Group Type
A group is designated as all, select, fast Failover, or indirect.
all: executes all the buckets in the group.
Each arriving packet is effectively cloned.
Each bucket will designate a different output port, so that the incoming
packet is then transmitted on multiple output ports.
This group is used for multicast or broadcast forwarding.

Unit 3 - 44

The Group Tables – Group Type
select:
Executes one bucket in the group, based on a switch-computed
selection algorithm (for example, hash on some user-configured tuple
or simple round robin).
The selection algorithm should implement equal load sharing or,
optionally, load sharing based on bucket weights assigned by the SDN
controller.

Unit 3 - 45

The Group Tables – Group Type
fast failover:
Executes the first live bucket.
Port liveness is managed by code outside
of the scope of OpenFlow and may have to
do with routing algorithms.

The buckets are evaluated in order, and
the first live bucket is selected.
This group type enables the switch to
change forwarding without requiring a
round trip to the controller.

Unit 3 - 46

The Group Tables – Group Type
indirect:
Allows multiple packet flows (that is, multiple flow
table entries) to point to a common group identifier.
This type provides for more efficient management by
the controller in certain situations.
For example, suppose that there are 100 flow entries that
have the same match value in the IPv4 destination address
match field, but differ in some other match field, but all of
them forward the packet to port X by including the action
Output X on the action list. We can instead replace this
action with the action Group GID, where GID is the ID of an
indirect group entry that forwards the packet to port X. If
the SDN controller needs to change from port X to port Y, it
is not necessary to update all 100 flow table entries. All that
is required is to update the group entry.
Unit 3 - 47

OpenFlow Protocol
The OpenFlow protocol describes message exchanges that take place
between an OpenFlow controller and an OpenFlow switch
Typically, the protocol is implemented on top of TLS, providing a secure
OpenFlow channel
The OpenFlow protocol enables the controller to perform add, update, and
delete actions to the flow entries in the flow tables
It supports three types of messages:

Controller to
switch

Asynchronous

Symmetric

Unit 3 - 48

OpenFlow Messages
Message
Features
Configuration
Modify-State
Read-State
Packet-out
Barrier
Role-Request
AsynchronousConfiguration
Packet-in
Flow-Removed
Port-Status
Role-Status
Controller-Status
Flow-monitor

Hello
Echo

Error
Experimenter

Description
Controller-to-Switch
Request the capabilities of a switch. Switch responds with a features reply that specifies its capabilities.
Set and query configuration parameters. Switch responds with parameter settings
Add, delete, and modify flow/group entries and set switch port properties.
Collect information from switch, such as current configuration, statistics, and capabilities.
Direct packet to a specified port on the switch.
Barrier request/reply messages are used by the controller to ensure message dependencies have been
met or to receive notifications for completed operations.
Set or query role of the OpenFlow channel. Useful when switch connects to multiple controllers.
Set filter on asynchronous messages or query that filter. Useful when switch connects to multiple
controllers.
Asynchronous
Transfer packet to controller.
Inform the controller about the removal of a flow entry from a flow table.
Inform the controller of a change on a port.
Inform controller of a change of its role for this switch from master controller to slave controller.
Inform the controller when the status of an OpenFlow channel changes. This can assist failover processing
if controllers lose the ability to communicate among themselves.
Inform the controller of a change in a flow table. Allows a controller to monitor in real time the changes to
any subsets of the flow table done by other controllers
Symmetric
Exchanged between the switch and controller upon connection startup.
Echo request/reply messages can be sent from either the switch or the controller, and must return an
echo reply.
Used by the switch or the controller to notify problems to the other side of the connection.
For additional functionality.

Unit 3 - 49

3.5 The functions of the SDN control plane

Unit 3 - 50

SDN control plane architecture
The SDN control layer maps
application layer service
requests into specific
commands and directives to
data plane switches and
supplies applications with
information about data plane
topology and activity.
The control layer is
implemented as a server or
cooperating set of servers
known as SDN controllers.
Let’s look at specific protocols
and standards implemented
within the control plane
Unit 3 - 51

SDN controllers functions
Shortest path forwarding:

Uses routing information collected
from switches to establish preferred
routes.

Notification manager:

Receives, processes, and forwards
an application events, such as alarm
notifications, security alerts, and state changes.

Security mechanisms: Provides isolation and security enforcement between
applications and services.

Topology manager: Builds and maintains switch interconnection topology
information.

Statistics manager: Collects data on traffic through the switches.
Device manager: Configures switch parameters and attributes and manages
flow tables entries.

Unit 3 - 52

Network Operating System (NOS)
The functionality provided by the SDN controller can be viewed as a
network operating system (NOS)
As with a conventional OS, NOS provides essential services,
common application programming interfaces (APIs), and an
abstraction of lower-layer elements to developers
The functions of an SDN NOS enable developers to define network
policies and manage networks without concern for the details of the
network device characteristics
Northbound interfaces enable developers to create software that
is independent not only of data plane details but to a variety of SDN
controller servers. (more details later..)

Unit 3 - 53

SDN controller implementations
A number of different initiatives, both commercial and open source,
have resulted in SDN controller implementations:

OpenDaylight

Open Network
Operating System
(ONOS)

POX

Beacon

Floodlight

Ryu

Onix

Unit 3 - 54

SDN controller implementations
OpenDaylight: An open source platform for network programmability to enable SDN,
written in Java. OpenDaylight was founded by Cisco and IBM.
Floodlight: An open source package developed by Big Switch Networks. Both a webbased and Java based GUI are available and most of its functionality is exposed through a
REST API.
Open Network Operating System (ONOS): An open source SDN NOS, a nonprofit
effort funded and developed by a number of carriers, such as AT&T and NTT, and other
service providers and supported by the Open Networking Foundation.
Ryu: An open source component-based SDN framework developed by NTT Labs.
Developed in python.
POX: An open source OpenFlow controller that has been implemented by a number of
SDN developers and engineers. POX has a well written API and documentation. It also
provides a web-based graphical user interface (GUI) and is written in Python.
Beacon: An open source package developed at Stanford. Written in Java. Beacon was the
first controller that made it possible for beginner programmers to work with and create a
working SDN environment.

Onix: Commercially available SDN controller, developed by VMWare, Google, and NTT.
Unit 3 - 55

SDN Controller Interfaces
The southbound interface provides the logical
connection between the SDN controller and
the data plane switches.
The most commonly implemented southbound
API is OpenFlow.
Other southbound interfaces include the
following:
Open vSwitch Database Management Protocol
(OVSDB): an open source software project
which implements virtual switching. OVS uses
OpenFlow for message forwarding in the control
plane for both virtual and physical ports.
Forwarding and Control Element Separation
(ForCES): An IETF effort that standardizes the
interface between the control plane and the
data plane for IP routers.

Unit 3 - 56

SDN Controller Interfaces
The northbound interface enables applications to access control
plane functions and services without needing to know the details of
the underlying network switches.
The northbound interface is more typically viewed as a software API
rather than a protocol.
Base controller function APIs: These APIs expose the basic
functions of the controller and are used by developers to create
network services.
Network service APIs: These APIs expose network services to the
north. For example, Firewalls, Routings, and Optimizations.
Northbound interface application APIs: These APIs expose
application-related services that are built on top of network services.
For Example, security-related services.

Unit 3 - 57

SDN Controller - Routing
The routing function comprises a protocol for collecting information about
the topology and traffic conditions of the network, and an algorithm for
designing routes through the network
There are two categories of routing protocols:

• Concerned with discovering
the topology of routers
within an AS and then
determining the best route
to each destination based
on different metrics
Interior router protocols
(IRPs) that operate within
an autonomous system (AS)

Exterior router protocols
(ERPs) that operate between
autonomous systems

• Need not collect as much
detailed traffic information
• Primary concern is to
determine reachability of
networks and end systems
outside of the AS

Unit 3 - 58

SDN Controller - Routing
Traditionally, the routing function is distributed among the routers
in a network. Each router is responsible for building up an image of
the topology of the network. For interior routing, each router as well
must collect information about connectivity and delays and then
calculate the preferred route for each IP destination address.

However, in an SDN-controlled network, the controller provides a
centralized routing that can develop a consistent view of the
network state to calculate shortest paths.
The data plane switches are relieved of the processing and storage
burden associated with routing, leading to improved performance.

Unit 3 - 59

SDN Controller - Routing
The centralized routing application performs two distinct functions:

Link discovery
The routing function needs to be aware of links between data plane
switches
Must be performed between a router and a host system and between a
router in the domain of this controller and a router in a neighboring domain
Discovery is triggered by unknown traffic entering the controller’s network
domain either from an attached host or from a neighboring router
Topology manager

Maintains the topology information for the network and calculates routes in
the network
Route calculation involves determining the shortest path between two data
plane nodes or between a data plane node and a host

Unit 3 - 60

3.6 An overview of OpenDaylight and REST
APIs

Unit 3 - 61

The OpenDaylight architecture

Unit 3 - 62

Service Abstraction Layer Model

Unit 3 - 63

Service Abstraction Layer Model
OpenDaylight is not tied to OpenFlow or any other specific southbound
interface. This provides greater flexibility in constructing SDN network
configurations.
The key element in this design is the SAL, which enables the controller to
support multiple protocols on the southbound interface and provide consistent
services for controller functions and for SDN applications.
The services manager maintains a registry that maps service requests to feature
requests. Based on the service request, the SAL maps to the appropriate plug-in
and thus uses the most appropriate southbound protocol to interact with a given
network device.

All code in the OpenDaylight project is implemented in Java and is contained
within its own Java Virtual Machine (JVM). As such, it can be deployed on any
hardware and operating system platform that supports Java.

Unit 3 - 64

OpenDaylight - the Helium release

Unit 3 - 65

OpenDaylight - the Helium release
The controller platform (exclusive of applications, which may also run on the
controller) consists of a growing collection of dynamically pluggable modules,
each of which performs one or more SDN-related functions and services.
Five modules are considered base network service functions:
Topology manager: A service for learning the network layout by subscribing to events
of node addition and removal and their interconnection. Applications requiring network
view can use this service.
Statistics manager: Collects switch-related statistics, including flow statistics, node
connector, and queue occupancy.
Switch manager: Holds the details of the data plane devices. As a switch is
discovered, its attributes (for example, what switch/router it is, software version,
capabilities) are stored in a database by the switch manager.
Forwarding rules manager: Installs routes and tracks next-hop information. Works in
conjunction with switch manager and topology manager to register and maintain
network flow state. Applications using this need not have visibility of network device
specifics.
Host tracker: Tracks and maintains information about connected hosts.

Unit 3 - 66

REpresentational State Transfer (REST)
An architectural style used to define APIs
This has become a standard way of constructing northbound APIs
for SDN controllers
A REST API, or an API that is RESTful is not a protocol, language, or
established standard
It is essentially six constraints that an API must follow to be RESTful
The objective of these constraints is to maximize the scalability and
independence/interoperability of software interactions, and to provide
for a simple means of constructing APIs

Unit 3 - 69

REST Constraints
The six REST constraints are:

1

• Client-server

2

• Stateless

3

• Cache

4

• Uniform interface

5

• Layered system

6

• Code on demand

Unit 3 - 70

(1) Client-Server
This simple constraint dictates that interaction between application
and server is in the client-server request/response style
The principle defined for this constraint is the separation of user
interface concerns from data storage concerns
This separation allows client and server components to evolve
independently and supports the portability of server-side functions
to multiple platforms

Unit 3 - 71

(2) Stateless Constraint
Dictates that each request from a client to a server must contain all
the information necessary to understand the request and cannot
take advantage of any stored context on the server
Similarly, each response from the server must contain all the
desired information for that request
One consequence is that any memory of a transaction is maintained
in a session state kept entirely on the client
Another consequence is that if the client and server reside on
different machines, and therefore communicate via a protocol, that
protocol need not be connection oriented
REST typically runs over Hypertext Transfer Protocol (HTTP), which
is a stateless protocol

Unit 3 - 72

(3) Cache Constraint
Requires that the data within a response to a request be implicitly
or explicitly labeled as cacheable or non-cacheable
If a response is cacheable, then a client cache is given the right to
reuse that response data for later, equivalent requests
Therefore, subsequent requests for the same data can be handled
locally at the client, reducing communication overhead between
client and server

Unit 3 - 73

(4) Uniform Interface Constraint
REST emphasizes a uniform interface between components,
regardless of the specific client-server application API implemented
using REST
To obtain a uniform interface, REST defines four interface
constraints:
Identification of resources
Manipulation of resources through representations
Self-descriptive messages
Hypermedia as the engine of the application state

The benefit of this constraint, for an SDN environment is that
different applications can invoke the same controller service via a
REST API

Unit 3 - 74

(5) Layered System Constraint
A given function is organized in layers, with each layer only having
direct interaction with the layers immediately above and below
This is a fairly standard architecture approach for protocol
architectures, OS design, and system services design

Unit 3 - 75

(6) Code-on-Demand Constraint
REST allows client functionality to be extended by downloading and
executing code in the form of applets or scripts
This simplifies clients by reducing the number of features required
to be pre-implemented
Allowing features to be downloaded after deployment improves
system extensibility

Unit 3 - 76

The API
functions for
retrieving switch
statistics and
parameters
that use the GET
message type.

Unit 3 - 77

APIs for Retrieving Switch and Updating Switch Statistics
and Parameters

Unit 3 - 78

Whiteboard

